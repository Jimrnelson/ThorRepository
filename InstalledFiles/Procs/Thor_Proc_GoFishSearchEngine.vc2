*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="thor_proc_gofishsearchengine.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS gofishsearchengine_thor AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "gofish.h"
	*<DefinedPropArrayMethod>
		*m: addcolumn		&& Adds a Column object to a Grid control.
		*m: addproject
		*m: assignmatchtype
		*m: assignmatchtypeforprg
		*m: assignmatchtypeforscxvcx
		*m: backupfile
		*m: builddirectoriescollection		&& Fill this.oDirectories collection with all folders under the current path. Recursive folder list is created. This is called by SearchInPath() to build a colecltions of folders to searhc through.
		*m: buildprojectscollection
		*m: changecurrentdir
		*m: checkfileexttemplate
		*m: checkfilenametemplate
		*m: cleanupbinarystring
		*m: clearreplaceerrormessage
		*m: clearreplacesettings
		*m: clearresultscollection
		*m: clearresultscursor
		*m: compile
		*m: createreplacedetailrecord
		*m: createreplacehistoryrecord
		*m: createresult
		*m: createresultsrow
		*m: dropcolumn
		*m: editfromcurrentrow
		*m: endtimer
		*m: escapesearchexpression
		*m: extractmethodname
		*m: extractobjectname
		*m: filestoskip
		*m: findprocedureformatch
		*m: generatehtmlcode
		*m: getactiveproject
		*m: getcurrentdirectory
		*m: getdirectories
		*m: getfiledatetime
		*m: getfrxobjecttype
		*m: getprocedurestartpositions
		*m: getregexforprocedurestartpositions
		*m: getregexforsearch
		*m: getreplaceresultobject
		*m: getreplacerisklevel
		*m: htmlencode
		*m: incrementprogressbar
		*m: isbaseclass		&& Returns .t. if passed string value is a native FoxPro baseclass.
		*m: iscomment		&& return .t. if "*" .or. "note"
		*m: isfiletypeincluded		&& A method that indicates if the passed filename is to be included in the search, based on the checkbox groups on the form.
		*m: isfulllinecomment
		*m: istextfile		&& Pass in a full filename or a file extension, and it will return .t. if it is a text file, or .f. if it is a table-based file.
		*m: loadoptions		&& Pass in XML File to load up search options.
		*m: lreadytoreplace_access
		*m: ltimestampdataprovided_access
		*m: matchtemplate
		*m: migratereplacedetailtable
		*m: opentableforreplace
		*m: prepareforsearch
		*m: prepareregexforreplace
		*m: prepareregexforsearch
		*m: processinlinecomments
		*m: processsearchresult
		*m: reduceprogressbarmaxvalue
		*m: regexreplace
		*m: renamecolumn
		*m: replacefromcurrentrow		&& This method performs a Replace operation on the current row of the passed cursor name.
		*m: replaceincode
		*m: replaceintable
		*m: replaceintextfile
		*m: replaceline
		*m: replacelinewithudf
		*m: replacemarkedrows		&& This method scans of the rows in passed cursor, and calls the ReplaceFromCurrentRow() method for each marked row.
		*m: restoredefaultdir
		*m: saveoptions
		*m: searchfinished		&& Called by SearchInPath() and SearchInProject() once they are finished. This will update some class properties, end the timer, and other cleanup stuff.
		*m: searchincode		&& Find text within text-based files like PRG,SPR,MPR, etc.
		*m: searchinfile		&& Both ProcessProject() and ProcessPath() pass their filenames into this method to have it processed.
		*m: searchinfilename
		*m: searchinpath
		*m: searchinproject
		*m: searchintable		&& Performs a search on a table-based file like a VCX, SCX, FRX, etc.
		*m: searchintextfile
		*m: setfilestoskip
		*m: setproject
		*m: setreplaceerror
		*m: setsearcherror
		*m: showerror
		*m: showwaitmessage
		*m: startprogressbar
		*m: starttimer
		*m: stopprogressbar
		*m: storeinitialdefaultdir
		*m: timestamptodate		&& Handles the conversion of the FoxPro TIMESTAMP field to a readable (and understandable) date and time. By Rick Schummer.
		*m: trimwhitespace
		*m: updatecursorafterreplace		&& Updates the match position fields on remaining rows in the results cursor after a replace opertion is performed on a row.
		*m: updateprogressbar
		*m: updatereplacehistoryrecord
		*p: cbackupprg
		*p: cfilestoskip
		*p: cfilestoskipfile		&& This files contains a list of files to be skipped during the search. One filname on each line. This list is only slipped is lSkipFiles is .t.
		*p: cgraphicsextensions
		*p: cinitialdefaultdir
		*p: cprojects		&& A text list of projects that matches oProjects. Makes looking for existing projects fast than analyzing the oProjects collection. This property is only to be used by the class. Please don't touch it.
		*p: creplacedetailtable		&& A detail record is stored here for every single match line that is replaced.
		*p: creplacehistorytable		&& A single header record is stored here for each time the ReplaceFromMarkedRows() method is called.
		*p: creplaceudfcode		&& Holds the code for a UDF to be used on Replace operations if nReplaceMode is the Advanced Replace mode
		*p: csearchoptionsclass		&& The default Search Options class to be used. Can be overriden by passing a string to the Init(I method.
		*p: csearchresultsalias		&& This is the name of the cursor where the results rows ill be stored.
		*p: ctableextensions		&& These are the filetypes that will be handled by the SearchInTable() method. All other filetypes are assumed to be plain text files and will be handled by the SearchInTextFile() method.
		*p: cversion
		*p: lescpress		&& Indicates if the ESC key was pressed by the user during on of the lower processing loops of a Search.
		*p: lfilehasbeenedited		&& This flag is set any time a MODIFY operation is launched from the grid. We asume they made changes to the file, requiring a new search before they can do a Replace. This prevents the REPLACE button from being available until the search is run again.
		*p: lfilenotfound		&& Will indicate if there were any files in a ProcessProject() or ProcessPath() that were not found. You can check this flag after a search call.
		*p: lreadytoreplace
		*p: lresultslimitreached		&& Indicates if the max search results limit was reach during a search. See nMaxResults property on the Search Options class.
		*p: lsearchoncepervcx
		*p: ltimestampdataprovided
		*p: nfilecount		&& This values indicates how many files were found to have matches in them.
		*p: nfilesprocessed		&& This values indicates the total number of files processed that matched the file filter, whether they had matches or not.
		*p: nmatchlines		&& How many matched lines found in the last search. Note: this counts lines that had a match, note each match. It's possible that one line could have multiple matches.
		*p: nreplacecount
		*p: nreplacefilecount
		*p: nreplacehistoryid		&& Store the current ID number of the Replace History record.
		*p: nreplacemode		&& 1= Regular replace, 2 = Advanced Replace (UDF Replace)
		*p: nsearchtime		&& Tells how long the last search took. It is only reset by SearchInPath() or SerachInProject() took, and not by the lower level search like SearchInFile, or SearchInTextFile, or SearchInTable.
		*p: ocustomprocessor
		*p: odirectories		&& Internally used by the SearcthInPath() to build a collection of directories to be searched.
		*p: ofrxcursor		&& An FFC class used to generate a TimeStamp so the TimeStamp field can be updated when replacing code in a table based file.
		*p: ofso
		*p: oprogressbar
		*p: oprojects		&& Internally created to show a collection of recently used Projects, or projects found in the current path folder. This is built so the GoFish Advanced form can allow user to choose a Project.
		*p: oregexforprocedurestartpositions
		*p: oregexforsearch
		*p: oreplaceerrors
		*p: oresults		&& This is a collection of match objects from the last search. Must set lCreateResultsCollection if you want this collection to be built
		*p: osearcherrors		&& A collection of any errors that happened during the last search.
		*p: osearchoptions		&& A object instance of the Search Options class that holds properties to controll how the search is performed.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cbackupprg = GoFishBackup.prg
	cfilestoskip = 
	cfilestoskipfile = ( Home(7) + 'GF_Files_To_Skip.txt')		&& This files contains a list of files to be skipped during the search. One filname on each line. This list is only slipped is lSkipFiles is .t.
	cgraphicsextensions = PNG ICO JPG JPEG TIF TIFF GIF BMP MSK CUR ANI
	cinitialdefaultdir = 
	cprojects = 		&& A text list of projects that matches oProjects. Makes looking for existing projects fast than analyzing the oProjects collection. This property is only to be used by the class. Please don't touch it.
	creplacedetailtable = ( Home(7) + 'GF_Replace_Detail.dbf')		&& A detail record is stored here for every single match line that is replaced.
	creplacehistorytable = ( Home(7) + 'GF_Replace_History.dbf')		&& A single header record is stored here for each time the ReplaceFromMarkedRows() method is called.
	creplaceudfcode = 		&& Holds the code for a UDF to be used on Replace operations if nReplaceMode is the Advanced Replace mode
	csearchoptionsclass = GoFishSearchOptions_Thor		&& The default Search Options class to be used. Can be overriden by passing a string to the Init(I method.
	csearchresultsalias = GFSE_SearchResults		&& This is the name of the cursor where the results rows ill be stored.
	ctableextensions = SCX VCX FRX MNX LBX DBC PJX DBF		&& These are the filetypes that will be handled by the SearchInTable() method. All other filetypes are assumed to be plain text files and will be handled by the SearchInTextFile() method.
	cversion = 
	Height = 46
	lescpress = .F.		&& Indicates if the ESC key was pressed by the user during on of the lower processing loops of a Search.
	lfilehasbeenedited = .F.		&& This flag is set any time a MODIFY operation is launched from the grid. We asume they made changes to the file, requiring a new search before they can do a Replace. This prevents the REPLACE button from being available until the search is run again.
	lfilenotfound = .F.		&& Will indicate if there were any files in a ProcessProject() or ProcessPath() that were not found. You can check this flag after a search call.
	lreadytoreplace = .F.
	lresultslimitreached = .F.		&& Indicates if the max search results limit was reach during a search. See nMaxResults property on the Search Options class.
	lsearchoncepervcx = .F.
	ltimestampdataprovided = .F.
	Name = "gofishsearchengine_thor"
	nfilecount = 0		&& This values indicates how many files were found to have matches in them.
	nfilesprocessed = 0		&& This values indicates the total number of files processed that matched the file filter, whether they had matches or not.
	nmatchlines = 0		&& How many matched lines found in the last search. Note: this counts lines that had a match, note each match. It's possible that one line could have multiple matches.
	nreplacecount = 0
	nreplacefilecount = 0
	nreplacehistoryid = 0		&& Store the current ID number of the Replace History record.
	nreplacemode = 1		&& 1= Regular replace, 2 = Advanced Replace (UDF Replace)
	nsearchtime = 0		&& Tells how long the last search took. It is only reset by SearchInPath() or SerachInProject() took, and not by the lower level search like SearchInFile, or SearchInTextFile, or SearchInTable.
	ocustomprocessor = .NULL.
	odirectories = .NULL.		&& Internally used by the SearcthInPath() to build a collection of directories to be searched.
	ofrxcursor = .NULL.		&& An FFC class used to generate a TimeStamp so the TimeStamp field can be updated when replacing code in a table based file.
	ofso = .NULL.
	oprogressbar = .NULL.
	oprojects = .NULL.		&& Internally created to show a collection of recently used Projects, or projects found in the current path folder. This is built so the GoFish Advanced form can allow user to choose a Project.
	oregexforprocedurestartpositions = .NULL.
	oregexforsearch = .NULL.
	oreplaceerrors = .NULL.
	oresults = .NULL.		&& This is a collection of match objects from the last search. Must set lCreateResultsCollection if you want this collection to be built
	osearcherrors = .NULL.		&& A collection of any errors that happened during the last search.
	osearchoptions = .NULL.		&& A object instance of the Search Options class that holds properties to controll how the search is performed.
	Width = 176
	_memberdata = <VFPData>
		<memberdata name="istextfile" display="IsTextFile"/>
		<memberdata name="isfiletypeincluded" display="IsFileTypeIncluded"/>
		<memberdata name="findprocedureformatch" display="FindProcedureForMatch"/>
		<memberdata name="getprocedurestartpositions" display="GetProcedureStartPositions"/>
		<memberdata name="csearchresultsalias" display="cSearchResultsAlias"/>
		<memberdata name="filestoskip" display="FilesToSkip"/>
		<memberdata name="width" display="Width"/>
		<memberdata name="height" display="Height"/>
		<memberdata name="clearreplacesettings" display="ClearReplaceSettings"/>
		<memberdata name="editfromcurrentrow" display="EditFromCurrentRow"/>
		<memberdata name="lreadytoreplace" display="lReadyToReplace"/>
		<memberdata name="lfilehasbeenedited" display="lFileHasBeenEdited"/>
		<memberdata name="replaceintextfile" display="ReplaceInTextFile"/>
		<memberdata name="escapesearchexpression" display="EscapeSearchExpression"/>
		<memberdata name="prepareregexforsearch" display="PrepareRegExForSearch"/>
		<memberdata name="oregexforsearch" display="oRegExForSearch"/>
		<memberdata name="oregexforprocedurestartpositions" display="oRegExForProcedureStartPositions"/>
		<memberdata name="getregexforprocedurestartpositions" display="GetRegExForProcedureStartPositions"/>
		<memberdata name="getregexforsearch" display="GetRegExForSearch"/>
		<memberdata name="starttimer" display="StartTimer"/>
		<memberdata name="endtimer" display="EndTimer"/>
		<memberdata name="lescpress" display="lEscPress"/>
		<memberdata name="prepareforsearch" display="PrepareForSearch"/>
		<memberdata name="lfilenotfound" display="lFileNotFound"/>
		<memberdata name="replaceincode" display="ReplaceInCode"/>
		<memberdata name="searchinpath" display="SearchInPath"/>
		<memberdata name="searchinproject" display="SearchInProject"/>
		<memberdata name="searchinfile" display="SearchInFile"/>
		<memberdata name="searchintable" display="SearchInTable"/>
		<memberdata name="searchincode" display="SearchInCode"/>
		<memberdata name="nfilecount" display="nFileCount"/>
		<memberdata name="prepareregexforreplace" display="PrepareRegExForReplace"/>
		<memberdata name="opentableforreplace" display="OpenTableForReplace"/>
		<memberdata name="showerror" display="ShowError"/>
		<memberdata name="clearreplaceerrormessage" display="ClearReplaceErrorMessage"/>
		<memberdata name="oresults" display="oResults"/>
		<memberdata name="clearresultscollection" display="ClearResultsCollection"/>
		<memberdata name="searchintextfile" display="SearchInTextFile"/>
		<memberdata name="osearchoptions" display="oSearchOptions"/>
		<memberdata name="csearchoptionsclass" display="cSearchOptionsClass"/>
		<memberdata name="ctableextensions" display="cTableExtensions"/>
		<memberdata name="clearresultscursor" display="ClearResultsCursor"/>
		<memberdata name="createresultsrow" display="CreateResultsRow"/>
		<memberdata name="getfiledatetime" display="GetFileDateTime"/>
		<memberdata name="ofrxcursor" display="oFrxCursor"/>
		<memberdata name="nsearchtime" display="nSearchTime"/>
		<memberdata name="loadoptions" display="LoadOptions"/>
		<memberdata name="saveoptions" display="SaveOptions"/>
		<memberdata name="lresultslimitreached" display="lResultsLimitReached"/>
		<memberdata name="nmatchlines" display="nMatchLines"/>
		<memberdata name="setproject" display="SetProject"/>
		<memberdata name="cinitialdefaultdir" display="cInitialDefaultDir"/>
		<memberdata name="restoredefaultdir" display="RestoreDefaultDir"/>
		<memberdata name="storeinitialdefaultdir" display="StoreInitialDefaultDir"/>
		<memberdata name="lreadytoreplace_access" display="lReadyToReplace_Access"/>
		<memberdata name="oprojects" display="oProjects"/>
		<memberdata name="ltimestampdataprovided" display="lTimeStampDataProvided"/>
		<memberdata name="ltimestampdataprovided_access" display="lTimeStampDataProvided_Access"/>
		<memberdata name="buildprojectscollection" display="BuildProjectsCollection"/>
		<memberdata name="odirectories" display="oDirectories"/>
		<memberdata name="builddirectoriescollection" display="BuildDirectoriesCollection"/>
		<memberdata name="getdirectories" display="GetDirectories"/>
		<memberdata name="showwaitmessage" display="ShowWaitMessage"/>
		<memberdata name="timestamptodate" display="TimeStampToDate"/>
		<memberdata name="htmlencode" display="HtmlEncode"/>
		<memberdata name="regexreplace" display="RegExReplace"/>
		<memberdata name="changecurrentdir" display="ChangeCurrentDir"/>
		<memberdata name="addproject" display="AddProject"/>
		<memberdata name="generatehtmlcode" display="GenerateHTMLCode"/>
		<memberdata name="searchinfilename" display="SearchInFileName"/>
		<memberdata name="getactiveproject" display="GetActiveProject"/>
		<memberdata name="getcurrentdirectory" display="GetCurrentDirectory"/>
		<memberdata name="extractobjectname" display="ExtractObjectName"/>
		<memberdata name="extractmethodname" display="ExtractMethodName"/>
		<memberdata name="cprojects" display="cProjects"/>
		<memberdata name="assignmatchtypeforscxvcx" display="AssignMatchTypeForScxVcx"/>
		<memberdata name="assignmatchtypeforprg" display="AssignMatchTypeForPrg"/>
		<memberdata name="assignmatchtype" display="AssignMatchType"/>
		<memberdata name="createresult" display="CreateResult"/>
		<memberdata name="getfrxobjecttype" display="GetFrxObjectType"/>
		<memberdata name="checkfilenametemplate" display="CheckFilenameTemplate"/>
		<memberdata name="checkfileexttemplate" display="CheckFileExtTemplate"/>
		<memberdata name="matchtemplate" display="MatchTemplate"/>
		<memberdata name="iscomment" display="IsComment"/>
		<memberdata name="isfulllinecomment" display="IsFullLineComment"/>
		<memberdata name="processinlinecomments" display="ProcessInlineComments"/>
		<memberdata name="osearcherrors" display="oSearchErrors"/>
		<memberdata name="oreplaceerrors" display="oReplaceErrors"/>
		<memberdata name="setreplaceerror" display="SetReplaceError"/>
		<memberdata name="setsearcherror" display="SetSearchError"/>
		<memberdata name="nreplacecount" display="nReplaceCount"/>
		<memberdata name="nreplacefilecount" display="nReplaceFileCount"/>
		<memberdata name="getreplaceresultobject" display="GetReplaceResultObject"/>
		<memberdata name="trimwhitespace" display="TrimWhiteSpace"/>
		<memberdata name="processsearchresult" display="ProcessSearchResult"/>
		<memberdata name="replacemarkedrows" display="ReplaceMarkedRows"/>
		<memberdata name="getreplacerisklevel" display="GetReplaceRiskLevel"/>
		<memberdata name="replacefromcurrentrow" display="ReplaceFromCurrentRow"/>
		<memberdata name="creplacehistorytable" display="cReplaceHistoryTable"/>
		<memberdata name="createreplacehistoryrecord" display="CreateReplaceHistoryRecord"/>
		<memberdata name="createreplacedetailrecord" display="CreateReplaceDetailRecord"/>
		<memberdata name="creplacedetailtable" display="cReplaceDetailTable"/>
		<memberdata name="nreplacehistoryid" display="nReplaceHistoryId"/>
		<memberdata name="backupfile" display="BackupFile"/>
		<memberdata name="cbackupprg" display="cBackupPRG"/>
		<memberdata name="updatecursorafterreplace" display="UpdateCursorAfterReplace"/>
		<memberdata name="oprogressbar" display="oProgressBar"/>
		<memberdata name="updateprogressbar" display="UpdateProgressBar"/>
		<memberdata name="incrementprogressbar" display="IncrementProgressBar"/>
		<memberdata name="stopprogressbar" display="StopProgressBar"/>
		<memberdata name="startprogressbar" display="StartProgressBar"/>
		<memberdata name="searchfinished" display="SearchFinished"/>
		<memberdata name="replaceintable" display="ReplaceInTable"/>
		<memberdata name="updatereplacehistoryrecord" display="UpdateReplaceHistoryRecord"/>
		<memberdata name="replaceline" display="ReplaceLine"/>
		<memberdata name="nfilesprocessed" display="nFilesProcessed"/>
		<memberdata name="reduceprogressbarmaxvalue" display="ReduceProgressBarMaxValue"/>
		<memberdata name="compile" display="Compile"/>
		<memberdata name="cleanupbinarystring" display="CleanUpBinaryString"/>
		<memberdata name="cversion" display="cVersion"/>
		<memberdata name="ofso" display="oFSO"/>
		<memberdata name="creplaceudfcode" display="cReplaceUDFCode"/>
		<memberdata name="nreplacemode" display="nReplaceMode"/>
		<memberdata name="replacelinewithudf" display="ReplaceLineWithUDF"/>
		<memberdata name="cfilestoskip" display="cFilesToSkip"/>
		<memberdata name="setfilestoskip" display="SetFilesToSkip"/>
		<memberdata name="ocustomprocessor" display="oCustomProcessor"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addcolumn		&& Adds a Column object to a Grid control.
		Lparameters tcTable, tcColumnName, tcColumnDetails
		
		Local lcAlias
		
		lcAlias = JustStem(tcTable)
		Try
			Alter Table (tcTable) Add Column &tcColumnName &tcColumnDetails 
		Catch
		Endtry
		
	ENDPROC

	PROCEDURE addproject
		Lparameters tcProject
		
		Local llAlreadyInCollection
		
		llAlreadyInCollection = AtLine(Upper(tcProject), Upper(this.cProjects)) <> 0
		
		If !llAlreadyInCollection
			This.oProjects.Add(Lower(tcProject))
			This.cProjects = This.cProjects + tcProject + Chr(13) 
		Endif  
	ENDPROC

	PROCEDURE assignmatchtype
		Lparameters toObject
		
		Local lcFileType, lcMatchType, lcName, lcTrimmedMatchLine, lcValue, loNameMatches, loValueMatches
		Local llError, llWorkingOnClassFromVCX
		Local llNameHasDot, loLineMatches
		
		lcFileType = Upper(toObject.Userfield.FileType)
		
		lcTrimmedMatchLine = This.TrimWhiteSpace(toObject.MatchLine)&& Trimmed version for display in the grid
		toObject.TrimmedMatchLine = lcTrimmedMatchLine
		
		*-- We read MatchType of of UserField, but from here on, until the result row is created, we will
		*-- moved this value of to toObject.MatchType, and do some tweaking on it to make it the right value.
		*-- We'll never change the value that was passed in on toObject.UserField.MatchType
		lcMatchType = toObject.Userfield.MatchType
		toObject.MatchType = lcMatchType
		*=============================================================================================
		* This area contains a few overrides that I've had to build in to make final tweeks on columns
		*=============================================================================================
		*-- Sometimes in a VCX/SCX the MethodName will be empty and MatchLine will contain the PROCEDURE name
		If Empty(toObject.methodname) And Upper(Getwordnum(lcTrimmedMatchLine , 1)) = 'PROCEDURE'
			toObject.MethodName = Getwordnum(lcTrimmedMatchLine, 2)
		EndIf
		
		If !Empty(toObject.MethodName)
			With toObject.Userfield
				If '.' $ toObject.MethodName
					._Name = Alltrim(._Name + '.' + This.ExtractObjectName(toObject.MethodName), 1, '.')
					toObject.MethodName = JustExt(toObject.MethodName)
					
					If ._ParentClass <> ._Baseclass
						._ParentClass = ''
						._Baseclass = ''
					Else
						.ContainingClass = ''
					EndIf
				Else
						.ContainingClass = ''
				Endif
		
				If !Empty(._Class) && Trim Class name off of the front (only affects VCX results)
					._Name = Strtran(._Name, ._Class + '.', '', 1, 1)
				Endif
			Endwith
		EndIf
		
		If Empty(toObject.UserField.Classloc)
			toObject.UserField._ParentClass = '' && Affects VCXs. PRGs will be address in these next lines
		Endif
		
		If lcFileType = 'PRG'
			With toObject.UserField
				.ContainingClass = ''
				._Class = toObject.oProcedure._ClassName
				._ParentClass = toObject.oProcedure._ParentClass
				._Baseclass = toObject.oProcedure._Baseclass
				If ._Name = ._Class
					._Name = ''
				EndIf
				If  Upper('ENDDEFINE') $ Upper(toObject.MethodName)
					toObject.MethodName = ''
					._Name = '' 
				EndIf
			EndWith
			
		Endif
		
		If Upper(lcMatchType) # 'RESERVED3' and This.IsFullLineComment(lcTrimmedMatchLine)
			toObject.MatchType = MATCHTYPE_COMMENT
			This.CreateResult(toObject)	
			Return .null. && Exit out, we're done with this record!
		EndIf
		
		*=============================================================================================
		* Handle a few tweaks on MatchType assignments
		*=============================================================================================
		This.ProcessInlineComments(toObject)
		
		Do Case
		
			*-- A TimeStamp only search, with no search expression...
			Case IsNull(toObject.oMatch)
				If This.oSearchOptions.lTimeStamp and Empty(This.oSearchOptions.cSearchExpression)
					If Empty(toObject.Userfield._Name) and Empty(toObject.Userfield.ContainingClass) and Empty(toObject.Userfield._Class)
						toObject.MatchType =  MATCHTYPE_FILEDATE
					Else
						toObject.MatchType =  MATCHTYPE_TIMESTAMP
					EndIf
				Else
					toObject.MatchType = MATCHTYPE_FILENAME
				Endif
		
			Case Inlist(lcFileType, 'SCX', 'VCX', 'FRX')&& And lcMatchType # MATCHTYPE_FILENAME
				This.AssignMatchTypeForScxVcx(toObject)
		
			Case lcFileType = 'PRG'
				This.AssignMatchTypeForPrg(toObject)
		
		Endcase
		
		*-- Read MatchType back off toObject for a final bit of tweaking...
		lcMatchType = toObject.MatchType
		
		Do Case 
			Case Empty(lcMatchType)
				lcMatchType = MATCHTYPE_CODE
				
			Case Upper(Getwordnum(lcTrimmedMatchLine , 1)) = '#DEFINE'
				lcMatchType = MATCHTYPE_CONSTANT
		
			Case lcMatchType = MATCHTYPE_PROPERTY_DESC or lcMatchType = MATCHTYPE_PROPERTY_DEF
				toObject.UserField.ContainingClass = ''
				toObject.UserField._Name = GetWordNum(toObject.MatchLine, 1, ' ')
				   
			Case lcMatchType = MATCHTYPE_PROPERTY  
		
				If Atc('=', lcTrimmedMatchLine) = 0
					toObject.MatchType = MATCHTYPE_CODE
					Return toObject
				Endif
					
				lcName = GetWordNum(lcTrimmedMatchLine, 1, ' =') && The Property Name only
						
				Try
					If Atc('.', lcName) > 0 && Could be ObjectName.ObjectName.ObjectName.PropertyName
						lcName = JustExt(lcName) && Need to pick off just the property name, and make sure that's where the match is.
						llNameHasDot = .t.
					Else
						llNameHasDot = .f.
					EndIf
					
					toObject.UserField._Name = lcName
					lcName = lcName + ' =' && Need to construct property name like this example:   Caption = 
					
					lcValue = GetWordNum(lcTrimmedMatchLine, 2, '=')
					loNameMatches = This.oRegExForSearch.Execute(lcName)
					loValueMatches = This.oRegExForSearch.Execute(lcValue)
					* loLineMatches = This.oRegExForSearch.Execute(lcTrimmedMatchLine)
					loLineMatches = This.oRegExForSearch.Execute(lcName + lcValue)
					
					With toObject.UserField
						If llNameHasDot
							If ._ParentClass <> ._Baseclass
								._ParentClass = ''
								._Baseclass = ''
							Else
								.ContainingClass = ''
							EndIf
						Else
							.ContainingClass = ''
						Endif
						If Empty(.Classloc)
							._ParentClass = ''
						Endif
					Endwith
		
					Do Case
						Case loNameMatches.count > 0 and loValueMatches.count > 0 && If match on both sides, make an extra call here for the Name
							toObject.MatchType = MATCHTYPE_PROPERTY_NAME
							This.CreateResult(toObject)
							lcMatchType = MATCHTYPE_PROPERTY_VALUE
						Case loNameMatches.count > 0 or loValueMatches.count > 0 && Only matched on one side
							lcMatchType = Iif(loNameMatches.count > 0, MATCHTYPE_PROPERTY_NAME, MATCHTYPE_PROPERTY_VALUE)
						Case loLineMatches.count > 0 && Matched SOMEWHERE on the line. Can span " = " this way
							*-- No modification to matchtype required. Will record as MATCHTYPE_PROPERTY
						Case loNameMatches.count = 0 and loValueMatches.count = 0 && Possible that there is not match at all, so we record nothing
							llError = .t.
						Otherwise
							*lcMatchType = Iif(loNameMatches.count > 0, MATCHTYPE_PROPERTY_NAME, MATCHTYPE_PROPERTY_VALUE)
					Endcase
				Catch
					lcMatchType = MATCHTYPE_CODE && IF anything above failed, then just consider this a regular code match
				Endtry
		
		EndCase
		
		If llError = .t.
			Return .null.
		EndIf
		
		*-- Wrap MatchType in brackets (if not already set), and if it's not MATCHTYPE_CODE ...
		If lcMatchType # MATCHTYPE_CODE And Left(lcMatchType, 1) # '<'
			lcMatchType = '<' + lcMatchType + '>'
		Endif
		
		toObject.MatchType = lcMatchType
		
		Return toObject     
	ENDPROC

	PROCEDURE assignmatchtypeforprg
		Lparameters toObject
		
		Local lcMatchType, lcParams, lcProcedureType, lnMatchStart, lnProcedureStart, loMatch, loMatches
		Local loProcedure
		Local lcName, lcTrimmedMatchLine, loNameMatches, loParamMatches
		
		loProcedure = toObject.oProcedure
		loMatch = toObject.oMatch
		lcMatchType = Upper(toObject.MatchType)
		lnProcedureStart = loProcedure.StartByte
		lnMatchStart = Iif(Vartype(loMatch) = 'O', loMatch.FirstIndex, 0)
		lcTrimmedMatchLine = toObject.TrimmedMatchLine
		
		Do Case
			Case lcMatchType = 'CLASS' && Note, this case also handles Properties on a Class...
				
				lcFirstWord = Upper(GetWordNum(lcTrimmedMatchLine, 1))
				If lcFirstWord $ 'PROCEDURE'
					lcMatchType = MATCHTYPE_PROCEDURE
				Else
					lcMatchType = Iif(lnMatchStart = lnProcedureStart, MATCHTYPE_CLASS_DEF, MATCHTYPE_PROPERTY)
				Endif
				*toObject.MethodName = ''
		
			Case InList(lcMatchType, 'METHOD', 'PROCEDURE', 'FUNCTION')
		
				*-- This test looks for matches in on the Procedure Name versus possible parameters:
				*-- Ex: PROCEDURE ProcessJob(lcJobNo). 
				If lnMatchStart = lnProcedureStart
						lcName = GetWordNum(lcTrimmedMatchLine, 1, '(')
						lcParams = GetWordNum(lcTrimmedMatchLine, 2, '(')
		
						loNameMatches = This.oRegExForSearch.Execute(lcName)
						loParamMatches = This.oRegExForSearch.Execute(lcParams)
		
						If loNameMatches.count > 0 and loParamMatches.count > 0 && If match on both sides, make an extra call here for the Name
							toObject.UserField.MatchType = '<' + Proper(lcMatchType) + '>'
							This.CreateResult(toObject)
							lcMatchType = MATCHTYPE_CODE
						Else
							lcMatchType = Iif(loParamMatches.count > 0, MATCHTYPE_CODE, Proper(lcMatchType))
						EndIf
				Else
					lcMatchType = MATCHTYPE_CODE
				Endif
				
			Otherwise
			 	lcMatchType = toObject.MatchType && Restore it back
		
		EndCase
		
		toObject.MatchType = lcMatchType
		
		 
	ENDPROC

	PROCEDURE assignmatchtypeforscxvcx
		Lparameters toObject
		
		Local lcClass, lcContainingClass, lcMatchType, lcMethodName, lcName, lcProcedureType, lcPropertyName
		Local lcTrimmedMatchLine, lnMatchStart, lnProcedureStart, loMatches
		
		lcMethodName = toObject.MethodName
		lcTrimmedMatchLine = toObject.TrimmedMatchLine
		
		lcProcedureType = toObject.oProcedure.type 
		lnProcedureStart = toObject.oProcedure.StartByte
		
		lnMatchStart = toObject.oMatch.FirstIndex
		lcMatchType = Upper(toObject.MatchType)
		
		With toObject.UserField
			lcClass = ._Class
			lcContainingClass = .ContainingClass
			lcName = ._Name
		Endwith
		
		Do Case
		
			Case Alltrim(lcClass) == Alltrim(lcTrimmedMatchLine) and !Empty(lcClass) and Empty(lcName)
					lcMatchType = MATCHTYPE_CLASS_DEF
		
			Case lcMatchType = 'RESERVED3'
				If Left(lcTrimmedMatchLine, 1) = '*' && A Method Definition line
					lcMethodName = Substr(lcTrimmedMatchLine, 2, Len(GetWordNum(lcTrimmedMatchLine, 1)) -1)
					loMatches = This.oRegExForSearch.Execute(lcMethodName)
					lcMatchType = Iif(loMatches.Count > 0, MATCHTYPE_METHOD_DEF, MATCHTYPE_METHOD_DESC)
				Else && A Property Definition line
					lcPropertyName = GetWordNum(lcTrimmedMatchLine, 1)
					If Atc('.', lcPropertyName) > 0
						lcPropertyName = JustExt(lcPropertyName)
					Endif
					loMatches = This.oRegExForSearch.Execute(lcPropertyName)
					lcMatchType = Iif(loMatches.Count > 0, MATCHTYPE_PROPERTY_DEF, MATCHTYPE_PROPERTY_DESC)
				EndIf
		
			Case lcMatchType = 'RESERVED7'
				lcMatchType = MATCHTYPE_CLASS_DESC
		
			Case lcMatchType = 'RESERVED8'
				lcMatchType = MATCHTYPE_INCLUDE_FILE
		
			Case lcMatchType = 'OBJNAME'
				lcMatchType = Iif(Empty(lcName), MATCHTYPE_CLASS, MATCHTYPE_NAME)
		
			Case lcMatchType = 'PROCEDURE'
				If lnMatchStart = lnProcedureStart and !Empty(toObject.oProcedure.ParentClass)
					lcMatchType = MATCHTYPE_METHOD
				Else
					lcMatchType = MATCHTYPE_CODE
				Endif
		
			Case lcMatchType = 'CLASS'
					lcMatchType = MATCHTYPE_CLASS
				
			Case lcMatchType = 'PROPERTIES'
				lcMatchType = MATCHTYPE_PROPERTY
								
			Otherwise 
					lcMatchType = toObject.MatchType && Restore it back
		
		EndCase
		
		toObject.MatchType = lcMatchType
		
		 
	ENDPROC

	PROCEDURE backupfile
		#Define ccBACKUPFOLDER Addbs(Home(7) + 'GoFishBackups')
		
		Lparameters tcFilePath, tnReplaceHistoryId
		
		Local lcBackupPRG, llCopyError
		Local laExtensions[1], lcDestFile, lcExt, lcExtensions, lcSourceFile, lcThisBackupFolder, lnI
		
		If This.oSearchOptions.lPreviewReplace = .t.
			Return
		Endif
		
		llCopyError = .f.
		
		*-- If the user has created a custom backup PRG, and placed it in their path, then call it instead
		lcBackupPRG = 'GoFish_Backup.prg'
		
		If File(lcBackupPRG)
			Do &lcBackupPRG With tcFilePath, tnReplaceHistoryId 
			Return
		Endif
		
		If Not Directory (ccBACKUPFOLDER) && Create main folder for backups, if necessary
			Mkdir (ccBACKUPFOLDER)
		Endif
		
		* Create folder for this ReplaceHistorrID, if necessary
		lcThisBackupFolder = Addbs (ccBACKUPFOLDER + Transform (tnReplaceHistoryId))
		
		If Not Directory (lcThisBackupFolder)
			Mkdir (lcThisBackupFolder)
		Endif
		
		* Determine the extensions we need to consider
		lcExt = Upper (Justext (tcFilePath))
		
		Do Case
			Case lcExt = 'SCX'
				lcExtensions = 'SCX,SCT'
			Case lcExt = 'VCX'
				lcExtensions = 'VCX,VCT'
			Case lcExt = 'FRX'
				lcExtensions = 'FRX,FRT'
			Case lcExt = 'MNX'
				lcExtensions = 'MNX,MNT,MPR,MPX'
			Case lcExt = 'DBC'
				lcExtensions = 'DBC,DCT,DCX'
			Case lcExt = 'LBX'
				lcExtensions = 'LBX,LBT'
			Otherwise
				lcExtensions = lcExt
		Endcase
		
		* Copy each file into the destination folder, if its not already there
		Alines (laExtensions, lcExtensions, 0, ',')
		
		For lnI = 1 To Alen (laExtensions)
			lcSourceFile = Forceext (tcFilePath, laExtensions (lnI))
			lcDestFile	 = lcThisBackupFolder + Justfname (lcSourceFile)
			If Not File (lcDestFile)
				Try
					Copy File (lcSourceFile) To (lcDestFile)
				Catch
					If !llCopyError
						This.SetReplaceError('Error creating backup of file.', tcFilePath, tnReplaceHistoryId) 
					Endif
					llCopyError = .t.			
				Endtry
			Endif
		Endfor
		  
		Return !llCopyError  
	ENDPROC

	PROCEDURE builddirectoriescollection		&& Fill this.oDirectories collection with all folders under the current path. Recursive folder list is created. This is called by SearchInPath() to build a colecltions of folders to searhc through.
		Lparameters tcDir
		
		*-- Note: This method is called recursively on itself if subfolders are found. See the For loop at the bottom...
		*-- For more good info on recursive processing of directories, see this page: http://fox.wikis.com/wc.dll?Wiki~RecursiveDirectoryProcessing
		
		Local laDirList[1], laFileList[1], lcCurrentDirectory, lcDriveAndDirectory, lnDirCount, lnPtr, lnFileCount
		
		If Lastkey() = 27 or Inkey() = 27
			This.lEscPress = .T.
			Clear Typeahead
			Return 0
		Endif
		
		Try
			Chdir (tcDir)
			llChanged = .t.
		Catch
		  llChanged = .f.
		EndTry
		
		If !llChanged
			Return .f.
		Endif
		
		This.ShowWaitMessage('Scanning directory ' + tcDir)
		
		lcCurrentDirectory = Curdir()
		lcDriveAndDirectory = Addbs(Sys(5) + Sys(2003))
		
		This.oDirectories.Add(lcDriveAndDirectory)
		
		lnDirCount = Adir(laDirList, '*.*', 'D')
		
		If Vartype(This.oProgressBar) = 'O'
			lnFileCount = ADir(laFileList, lcDriveAndDirectory + '*.*')
			This.oProgressBar.nMaxValue = This.oProgressBar.nMaxValue + lnFileCount
		Endif
		
		For lnPtr = 1 To lnDirCount
			If 'D' $ laDirList(lnPtr, 5) && If we have found another dir, then we need to work through it also
				If Vartype(This.oProgressBar) = 'O'
					This.oProgressBar.nMaxValue = This.oProgressBar.nMaxValue - 0 && Subtract off directories from file count
				Endif
				lcCurrentDirectory = laDirList(lnPtr, 1)
				If lcCurrentDirectory <> '.' And lcCurrentDirectory <> '..'
					This.BuildDirectoriesCollection(lcCurrentDirectory)
				Endif
			Endif
		Endfor
		
		Cd ..
		   
	ENDPROC

	PROCEDURE buildprojectscollection
		Local loPEME_BaseTools as 'GF_PEME_BaseTools' OF 'Lib\GF_PEME_BaseTools.vcx'
		Local laProjects[1], lcCurrentDir, lcProject, loMRU_Project, loMRU_Projects, loProject
		*:Global ix
		
		lcCurrentDir = Addbs(Sys(5) + Sys(2003)) && Current Default Drive and path
		
		*-- Blank out current Projects collecitons. Will rebuild below...
		This.oProjects = CreateObject('Collection')
		This.cProjects = ''
		
		If Version(2) = 0 && If we are running from an .EXE file then exit (No projects will be open)
			Return
		Endif
		
		*-- Add all open Projects in _VFP to the Collection
		For each loProject in _VFP.Projects
			lcProject = Lower(loProject.Name)
			This.AddProject(lcProject) 
			This.cProjects = This.cProjects + lcProject + Chr(13)
		Endfor
		
		*-- Add any Projects in the current folder
		Adir(laProjects, lcCurrentDir + '*.pjx')
		
		For ix = 1 To Alen(laProjects) / 5
			lcProject = Lower(FullPath(laProjects(ix, 1)))
			This.AddProject(lcProject)
			This.cProjects = This.cProjects + lcProject + Chr(13)
		Endfor
		
		*-- Add MRU Projects to the Collection...
		* loPEME_BaseTools = NewObject('GF_PEME_BaseTools', 'Lib\GF_PEME_BaseTools.vcx')
		
		* loMRU_Projects = loPEME_BaseTools.GetMRUList('PJX')
		
		* For Each loMRU_Project in loMRU_Projects
		* 	lcProject = Lower(loMRU_Project)
		* 	This.AddProject(lcProject)
		* 	This.cProjects = This.cProjects + lcProject + Chr(13)
		* Endfor
		
		
		
		
		 
	ENDPROC

	PROCEDURE changecurrentdir
		Lparameters tcDir
		
		Local lcCurrentDirectory, lcDefaultDrive, lcPath, llReturn
		
		*-- Attempt to change current dir to passed in location -------
		If !Empty(tcDir)
			Try
				Cd (tcDir)
				llReturn = .t.
			Catch
				This.SetSearchError('Invalid path [' + tcDir + '] passed to ChangeCurrentDir() method.')
				llReturn = .f.
			EndTry
		Else
			llReturn = .t.
		EndIf
		
		This.BuildProjectsCollection()
		
		Return llReturn
		
		
		
		
		
		 
		
		 
		
		 
		
		 
		 
	ENDPROC

	PROCEDURE checkfileexttemplate
		Lparameters tcFile
		
		Local lcFilename, lcFilenameMask, llFilenameMatch
		
		lcFileExtTemplate = JustExt(This.oSearchOptions.cFileTemplate)
		
		llReturn = This.MatchTemplate(tcFile, lcFileExtTemplate)
		
		
		
		
		
	ENDPROC

	PROCEDURE checkfilenametemplate
		Lparameters tcFile
		
		Local lcFilename, lcFilenameMask, llMatch, lnLength
		
		If Empty(JustStem(This.oSearchOptions.cFileTemplate))
			Return .t.
		EndIf
		
		lcFilenameMask = Upper(JustStem(This.oSearchOptions.cFileTemplate))
		lcFilename = Upper(JustStem(tcFile))
		
			Do Case
				Case lcFilenameMask = '*'
					llMatch = .t.
				Case (Left(lcFilenameMask, 1) = '*' and Right(lcFilenameMask, 1) = '*') or Atc('*', lcFilenameMask) = 0
					llMatch = lcFilenameMask $ lcFilename
				Case Right(lcFilenameMask, 1) = '*'
					lnLength = Len(cFilenameMask) - 1
					lcFilenameMask = Left(lcFilenameMask, lnLength)
					llMatch = Left(lcFilename, lnLength) = lcFilenameMask
				Case Left(lcFilenameMask, 1) = '*'
					lnLength = Len(cFilenameMask) - 1
					lcFilenameMask = Right(lcFilenameMask, lnLength)
					llMatch = Right(lcFilename, lnLength) = lcFilenameMask
			Endcase
		
		Return llMatch 
	ENDPROC

	PROCEDURE cleanupbinarystring
		Lparameters tcString, llClipAtChr8
		
		If llClipAtChr8 && The Select statement from a DBC View needs to be clipped at the Chr(8) near the end of the statement
			lnStart = Atc(Chr(8), tcString)
			tcString = Left(tcString, lnStart)
		Endif
		
		*-- Replace junk characters with a space
		For x = 0 to 31
			tcString = Strtran(tcString, Chr(X), ' ')
		EndFor
		
		Return tcString
	ENDPROC

	PROCEDURE clearreplaceerrormessage
		This.oSearchOptions.cReplaceErrorMessage = ''
		
	ENDPROC

	PROCEDURE clearreplacesettings
		This.oSearchOptions.lAllowBlankReplace = .F.
		This.oSearchOptions.cReplaceExpression = ''
		
		
		
	ENDPROC

	PROCEDURE clearresultscollection
		This.oResults = CreateObject('Collection')
	ENDPROC

	PROCEDURE clearresultscursor
		Local lcSearchResultsAlias, lnSelect
		
		lnSelect = Select()
		
		lcSearchResultsAlias = This.cSearchResultsAlias
		
		Create Cursor (lcSearchResultsAlias)( ;
			  Process L, ;
			  FilePath C(254), ;
			  Filename C(50), ;
			  TrimmedMatchLine C(254), ;
			  Baseclass C(254), ;
			  ParentClass C(254), ;
			  Class C(254), ;
			  Name C(254), ;
			  MethodName C(80), ;
			  ContainingClass C(254), ;
			  Classloc c(254), ;
			  MatchType C(25), ;
			  Timestamp T, ;
			  FileType C(4), ;
			  Type C(12), ;
			  Recno N(6, 0), ;
			  procstart I, ;
			  matchstart I, ;
			  matchlen I, ;
			  lIsText L, ;
			  Column C(10), ;
			  Code M, ;
			  Id I, ;
			  MatchLine M, ;
			  Replaced L, ;
			  TrimmedReplaceLine C(254), ;
			  ReplaceLine C(254), ;
			  ReplaceRisk I, ;
			  Replace_DT T;
			  )
		
		Select (lnSelect)
		 
	ENDPROC

	PROCEDURE compile
		Lparameters tcFile
		
		Local lcExt
		
		If This.oSearchOptions.lPreviewReplace = .t.
			Return
		Endif
		
		lcExt = Alltrim(Upper(Justext(tcFile)))
		
		Do Case
		
			Case lcExt = 'VCX'
				Compile ClassLib (tcFile)
		
			Case lcExt = 'SCX'
				Compile Form (tcFile)
		
			Case lcExt = 'LBX'
				Compile Label (tcFile)
		
			Case lcExt = 'FRX'
				Compile Report (tcFile)
		
		Endcase 
	ENDPROC

	PROCEDURE createreplacedetailrecord
		Lparameters toReplace
		
		Local lcDBC, lnId, lnSelect
		
		If This.oSearchOptions.lPreviewReplace = .t. && Do nothing if we are only in Preview mode
			Return
		Endif
		
		lnSelect = Select()
		
		lcDBC = Strtran(Upper(this.cReplaceDetailTable), '.DBF', '.DBC')
		
		If !File(this.cReplaceDetailTable) or !File(lcDBC)
			Set Safety off
			Delete File (lcDBC)
			Set Safety on
			Create Database (lcDBC)
			Select (this.cSearchResultsAlias)
			Copy Structure to (this.cReplaceDetailTable) DATABASE (lcDBC)
			Use In (This.cReplaceDetailTable)
		Endif
		
		This.MigrateReplaceDetailTable()
		
		toReplace.Replace_dt = Datetime()
		toReplace.Replaced = .t.
		AddProperty(toReplace, 'Batch_Id', This.nReplaceHistoryId)
		
		Insert Into (This.cReplaceDetailTable) From Name toReplace
		
		Select(lnSelect) 
	ENDPROC

	PROCEDURE createreplacehistoryrecord
		Local lcScope, lnSelect
		
		If This.oSearchOptions.lPreviewReplace = .t. && Do nothing if we are only in Replace Preview mode
			Return
		EndIf
		
		lnSelect = Select()
		
		If !File(This.cReplaceHistoryTable)
			Create Table (This.cReplaceHistoryTable) FREE (; 
				Id I AutoInc NextValue 1001, ;
				date_time T, ;
				replaces I, ;
				scope C(254), ;
				searchstr C(254), ;
				replacestr C(254) ;
				) 
		Endif
		
		If InList(this.oSearchOptions.nSearchScope, 1, 2)
			lcScope = This.oSearchOptions.cProject
		Else
			lcScope = This.oSearchOptions.cPath
		EndIf
		
		Insert Into (This.cReplaceHistoryTable) (scope, date_time, searchstr, replacestr) ; 
			Values (lcScope, Datetime(), This.oSearchOptions.cSearchExpression, This.oSearchOptions.cReplaceExpression)
		 
		This.nReplaceHistoryId = Evaluate(JustStem(JustFname(This.cReplaceHistoryTable)) + '.Id') 
		
		Select (lnSelect)  
	ENDPROC

	PROCEDURE createresult
		Lparameters toObject
		
		*loObject = This.AssignMatchType(toObject)
		
		This.nMatchLines = This.nMatchLines + 1
		
		If This.oSearchOptions.lCreateResultsCursor
			This.CreateResultsRow(toObject)
		EndIf
		
		If This.oSearchOptions.lCreateResultsCollection
			this.oResults.Add(toObject)
		EndIf
		
		
	ENDPROC

	PROCEDURE createresultsrow
		Lparameters toObject
		
		*-- This set of mem vars is required to insert a new row into the local results cursor.
		*-- The passed in toObject must be an object which has the reference prooperties on it, so
		*-- that a complete record can be created.
		
		Local lIsText, lcObjectNameFromProperty, lcProperty, lcResultsAlias, lnWords
		Local TimeStamp, code, column, containingclass, filename, filepath, filetype, id
		Local name, parentclass, baseclass, class, classloc
		Local matchlen, matchline, matchstart, matchtype, methodname, process, procstart, recno
		Local replacerisk, trimmedmatchline
		
		lcResultsAlias = this.cSearchResultsAlias
		
		With toObject
			m.methodname = .MethodName
			m.matchline = .MatchLine
			m.trimmedmatchline = .TrimmedMatchLine
			m.procstart = .ProcStart
			m.matchstart = .MatchStart
			m.matchlen = .MatchLen
			m.matchtype = .MatchType
			m.code = .Code
		Endwith
		
		With toObject.UserField
			m.process = .f.
			m.filepath = Lower(.FilePath)
			m.filename = Lower(.FileName)
			m.filetype = .FileType
			m.lIsText = .IsText
			m.baseclass = ._Baseclass
			m.ParentClass = ._ParentClass 
			m.containingclass = .ContainingClass
			m.name = ._Name
			m.class = ._Class
			m.classloc = .Classloc
			m.recno = .Recno && from the VCX, SCX, VCX, etc.
			m.TimeStamp = .TimeStamp 
			m.column = .Column
		EndWith
		
		* *-- Removed 07/07/2012
		* *--- Clean up / doctor up the Object Name
		* If 'scx' $ Lower(m.filetype)  && trim off the form name from front of object name
		* 	m.name = Substr(m.name, Atc('.', m.name) + 1)
		* EndIf
		
		*--- Sometimes, part of the object name may live on the match line
		*--- So, we need to append it to the end of the object name
		If m.matchtype $ (MATCHTYPE_PROPERTY_NAME + MATCHTYPE_PROPERTY_VALUE)
			lcObjectNameFromProperty = '' 
			lcProperty = GetWordNum(m.trimmedmatchline, 1)
			lnWords = GetWordCount(lcProperty, '.')
		
			If lnWords > 1
				lcObjectNameFromProperty = Left(lcProperty, Atc('.', lcProperty, lnWords - 1) - 1)
			Endif
			
			m.name = Alltrim(m.name + '.' + lcObjectNameFromProperty, '.')
		EndIf
		
		*--------------------------------------------------------------------------------
		
		m.id = Reccount(lcResultsAlias) + 1 && A unique key for each record
		
		m.replacerisk = This.GetReplaceRiskLevel(toObject)
		
		Insert Into &lcResultsAlias From Memvar
		         
	ENDPROC

	PROCEDURE Destroy
		This.oRegExForProcedureStartPositions = .Null.
		This.oRegExForSearch = .Null.
		This.oResults = .Null.
		This.oSearchOptions = .Null.
		This.oFrxCursor = .Null.
		This.oProjects = .Null.
		This.oSearchErrors = .Null.
		This.oReplaceErrors = .Null.
		This.oDirectories = .Null.
		This.oProgressBar = .Null.
		This.oFSO = .Null.
		
		
		
	ENDPROC

	PROCEDURE dropcolumn
		Lparameters tcTable, tcColumnName
		
		Local lcAlias
		
		lcAlias = JustStem(tcTable)
		Try
			Alter Table (tcTable)  Drop Column &tcColumnName
		Catch
		Endtry
		
	ENDPROC

	PROCEDURE editfromcurrentrow
		Lparameters tcCursor
		
		Local loPBT as 'GF_PEME_BaseTools'
		Local lcClass, lcCodeBlock, lcExt, lcFileToEdit, lcMatchType, lcMethod, lcMethodString, lcName
		Local lcProperty, lnMatchStart, lnProcStart, lnRecno, lnStart, lnWords, loTools
		
		lcExt = Alltrim(Upper(&tcCursor..filetype))
		lcFileToEdit = Upper(Alltrim(&tcCursor..filepath))
		lcClass= Alltrim(&tcCursor..class)
		lcName = Alltrim(&tcCursor..Name)
		lcMethod = Alltrim(&tcCursor..methodname)
		lcMatchType = Alltrim(&tcCursor..matchtype)
		lnRecno = &tcCursor..recno
		lnProcStart = &tcCursor..procstart
		lnMatchStart = &tcCursor..matchstart
		lcMethodString = Alltrim(lcName + '.' + lcMethod, 1, '.')
		
		
		If lcExt $ ' SCX VCX '
			*-- Calculate Line No from procstart and matchstart postitions...
			lcCodeBlock = Substr(&tcCursor..code, lnProcStart + 1, lnMatchStart - lnProcStart)
			lnStart = GetWordCount(lcCodeBLock, Chr(13)) - 1 && The LINE NUMBER that match in on within the method
			lnStart = Iif(lnStart > 0, lnStart, 1)
		Else
			lnStart = (&tcCursor..matchstart) + 1 && The CHARACTER position of the line where the match is on
		Endif
		
		Do Case
			Case lcExt = 'SCX'
				lcClass= ''
				*If Lower(Alltrim(&tcCursor..Baseclass)) <> 'form'
					lcMethodString = 'x.' + lcMethodString
				*EndIf
		
			Case lcExt = 'VCX'
				If lcName = lcClass
					lcMethodString 	= lcMethod
				Endif
		Endcase
		
		
		loPBT = CreateObject('GF_PEME_BaseTools')
		loPBT.EditSourceX(lcFileToEdit, lcClass, lnStart, lnStart, lcMethodString, lnRecno) 
		
		*-- 2011-12-28 (As requested by JRN) -------------
		*-- The following code will automatically select the actuall Object on the form or class, or select the Property name.
		*-- This will also select the it in the PEM Editor main form.
		If Type('_Screen.cThorDispatcher') = 'C'
		
			loTools = ExecScript(_Screen.cThorDispatcher, "Class= tools from pemeditor")
		
			If Vartype(loTools) = 'O'
		
				If lcExt = 'SCX' and &tcCursor..Baseclass = 'form' && Must trim off form name from front of object name
					lcName = ''
				EndIf
		
				Do Case 
					Case lcMatchType = MATCHTYPE_NAME  
						loTools.SelectObject(lcName) 
		
					Case lcMatchType $ (MATCHTYPE_PROPERTY_NAME + MATCHTYPE_PROPERTY_VALUE + MATCHTYPE_PROPERTY_DEF )
						*-- Pull out the Property name from the MatchLine (it can be preceded by an object name)
						lcProperty = GetWordNum(&tcCursor..trimmedmatchline, 1)
						lnWords = GetWordCount(lcProperty, '.')
						lcProperty = GetWordNum(lcProperty, lnWords, '. ')					
		
				  		loTools.SelectObject(lcName, lcProperty)
				Endcase
			EndIf
			
		Endif
		
		
		   
	ENDPROC

	PROCEDURE endtimer
		This.nSearchTime = Seconds() - This.nSearchTime
	ENDPROC

	PROCEDURE escapesearchexpression
		Lparameters tcString
		
		Local lcString
		
		lcString = tcString
		
		lcString = Strtran(tcString, '\', '\\')
		lcString = Strtran(lcString, '+', '\+')
		lcString = Strtran(lcString, '.', '\.')
		lcString = Strtran(lcString, '|', '\|')
		lcString = Strtran(lcString, '{', '\{')
		lcString = Strtran(lcString, '}', '\}')
		lcString = Strtran(lcString, '[', '\[')
		lcString = Strtran(lcString, ']', '\]')
		lcString = Strtran(lcString, '(', '\(')
		lcString = Strtran(lcString, ')', '\)')
		lcString = Strtran(lcString, '$', '\$')
		
		lcString = Strtran(lcString, '^', '\^')
		lcString = Strtran(lcString, ':', '\:')
		lcString = Strtran(lcString, ';', '\;')
		lcString = Strtran(lcString, '-', '\-')
		
		If This.oSearchOptions.nSearchMode = GF_SEARCH_MODE_LIKE 
			lcString = Strtran(lcString, '?', '.')
			lcString = Strtran(lcString, '*', '.*')
		Else
			lcString = Strtran(lcString, '?', '\?')
			lcString = Strtran(lcString, '*', '\*')
		Endif
		
		Return lcString
		
		
		* http://stackoverflow.com/questions/280793/case-insensitive-string-replacement-in-javascript
		
		
		*!*	RegExp.escape = function(str) {
		*!*	var specials = new RegExp("[.*+?|()\\[\\]{}\\\\]", "g"); // .*+?|()[]{}\
		*!*	return str.replace(specials, "\\$&");
		*!*	}  
	ENDPROC

	PROCEDURE extractmethodname
		Lparameters tcReference
		
		If !Empty(tcReference)
			Return JustExt(tcReference)
		Else
			Return ''
		Endif
	ENDPROC

	PROCEDURE extractobjectname
		Lparameters tcReference
		
		If !Empty(tcReference)
			Return JustStem(tcReference)
		Else
			Return ''
		Endif
		
	ENDPROC

	PROCEDURE filestoskip
		Lparameters tcFile
		
		Local lcFilename, llSkipFile
		
		lcFilename = Upper(JustFname(tcFile))
		
		llSkipFile = (Chr(13) + lcFilename + Chr(13) $ This.cFilesToSkip)
		
		Return llSkipFile
		
		
		
		
		 	    	
	ENDPROC

	PROCEDURE findprocedureformatch
		Lparameters toProcedureStartPositions, tnStartByte
		
		Local loReturn as 'GF_Procedure'
		Local loClassDef as 'GF_Procedure'
		Local llClassDef, lnX, loNextMatch
		
		loReturn = CreateObject('GF_Procedure')
		
		If IsNull(toProcedureStartPositions)
		 Return loReturn
		EndIf
		
		lnX = 1
		
		For Each result In toProcedureStartPositions
		
			If result.startbyte > tnStartByte
				exit
			Else
				loReturn = result
			EndIf
		
			Do Case
				Case 'END CLASS' $ Upper(result.Type)
					llClassDef = .f.
					loClassDef = CreateObject('GF_Procedure') && An empty result
				Case 'CLASS' $ Upper(result.Type)
					llClassDef = .t.
					loClassDef = result
			EndCase
			
			lnX = lnX + 1
		Endfor
		
		*-- This code attempted to identify matches that we INSIDE of a CLASS, but not inside of a Proc.
		*-- This would catch wildly located code in class that is between Proc definitions.
		* Removed 10/04/2012
		* If lnX < toProcedureStartPositions.count and llClassDef
		* 	loNextMatch = toProcedureStartPositions.Item(lnX + 1)
		* 	If tnStartByte < loNextMatch.StartByte
		* 		loReturn = loClassDef
		* 	Endif
		* Endif
		
		Return loReturn 
	ENDPROC

	PROCEDURE generatehtmlcode
		Lparameters tcCode, tcMatchLine, tnMatchStart, tcCss, tcJavaScript, tcReplaceLine, tlAlreadyReplaced
		
		Local lcColorizedCode, lcCss, lcHtml, lcHtmlBody, lcInitialBr, lcJavaScript, lcLeft, lcMatchLine
		Local lcMatchPrefix, lcMatchSuffix, lcMatchWordPrefix, lcMatchWordSuffix, lcReplaceExpression
		Local lcRight, lcRightCode, lnEndProc, lnMatchLineLength, lcBr
		Local lcMatchLinePrefix, lcMatchLineSuffix, lcReplaceLine
		Local lcReplaceLinePrefix, lcReplaceLineSuffix, lnReplaceLineLength 
		
		lcCss = Evl(tcCss, '')
		lcJavaScript = Evl(tcJavaScript, '')
		
		lcMatchLinePrefix = '<div id="matchline" class="matchline">'
		lcMatchLineSuffix = '</div>'
		lcReplaceLinePrefix = '<div id="repalceline" class="replaceline">'
		lcReplaceLineSuffix = '</div>'
		
		lcMatchWordPrefix = '<span id="matchword" class="matchword">'
		lcMatchWordSuffix = '</span>'
		
		If !Empty(tcMatchLine)
		
				*-- Dress up the code that comes before the match line...
				lcBr = '<br />'
				lcLeft = Left(tcCode, tnMatchStart)
				lcLeft = Evl(This.HtmlEncode(lcLeft), lcBr) 
		
				*-- Dress up the matchline...
				lnMatchLineLength = Len(tcMatchLine)
				lnReplaceLineLength = Len(Rtrim(tcReplaceLine))
				
				*=====================Colorize the Replace Preview line, if passed ==============================
				If !Empty(tcReplaceLine)
					lcColorizedCode = This.HtmlEncode(tcReplaceLine)
					lcReplaceLine = lcReplaceLinePrefix + lcColorizedCode + lcReplaceLineSuffix
					lcMatchLinePrefix = '<div id="matchline" class="strikeout">'
					lcMatchLinePrefix = lcMatchLinePrefix + '<del>'
					lcMatchLineSuffix = lcMatchLineSuffix + '</del>'
				Else
					lcReplaceLine = ''
				Endif
				
				*=====================COLORIZE THE MATCH LINE ============================================================================
				*-- Mark the match WORD(s), so I can find them after the VFP code is colorized...
				lcReplaceExpression = '[:GOFISHMATCHWORDSTART:] + lcMatch + [:GOFISHMATCHWORDEND:]'
				lcColorizedCode = This.RegExReplace(tcMatchLine, '', lcReplaceExpression, .t.)
		
				lcColorizedCode = This.HtmlEncode(lcColorizedCode)
		
				*-- Next, add <span> tags around previously marked match Word(s)
				lcColorizedCode = Strtran(lcColorizedCode, ':GOFISHMATCHWORDSTART:', lcMatchWordPrefix)
				lcColorizedCode = Strtran(lcColorizedCode, ':GOFISHMATCHWORDEND:', lcMatchWordSuffix)
				
				*-- Finally, add <div> tags around the entire Matched Line -------------------
				lcMatchLine = lcMatchLinePrefix + lcColorizedCode + lcMatchLineSuffix
				*=================================================================================================
				
				*-- Dress up the code that comes after the match line...
				*-- (Look for ENDPROC to know where to end the code)---
				If tlAlreadyReplaced = .t.
					lcRightCode = Substr(tcCode, tnMatchStart + 1 + lnReplaceLineLength)
				Else
					lcRightCode = Substr(tcCode, tnMatchStart + 1 + lnMatchLineLength)
				Endif
				
				lnEndProc = Atc('ENDPROC', lcRightCode)
		
				If lnEndProc > 0
					lcRightCode = Substr(lcRightCode, 1, lnEndProc + 6) && It ends at "E" of "ENDPROC", so add 6 to get the rest of the word
				Endif
		
				lcRight = This.HtmlEncode(lcRightCode)
		
				lcHtmlBody = lcLeft + lcMatchLine + lcReplaceLine + lcRight &&Build the body		
		Else
		
			*-- Just a plain blob of VFP code, with no match lines or match words...
			*-- Need an empty MatchLine Divs so the JavaScript on the page will find it to scroll the page
			lcHtmlBody = '<div id="matchline"></div>' + This.HtmlEncode(tcCode)
		
		Endif
		
		*-- Build the whole Html by combining the html parts defined above -------------
		Text to lcHtml NoShow TextMerge PRETEXT 3
			<html>
				<head>
					<<lcCss>>
				</head>
		
				<body>
					<<lcHtmlBody>>
					<br /><br /><br />
					<<lcJavaScript>>
				</body>
			</html>
		EndText
		
		
		Return lcHtml
		
		
		
		       
	ENDPROC

	PROCEDURE getactiveproject
		Local lcCurrentProject
		
		If Type('_VFP.ActiveProject.Name') = 'C'
			lcCurrentProject = _VFP.ActiveProject.Name
		Else
			lcCurrentProject = ''
		EndIf
		
		Return lcCurrentProject 
	ENDPROC

	PROCEDURE getcurrentdirectory
		
		Return Addbs(Sys(5) + Sys(2003))
	ENDPROC

	PROCEDURE getdirectories
		Lparameters tcPath, tlIncludeSubDirectories
		
		Local laFiles[1], lnFiles
		
		This.oDirectories = CreateObject('Collection')
		
		If tlIncludeSubdirectories 
			This.BuildDirectoriesCollection(tcPath)
		Else
			This.oDirectories.Add(tcPath)
			If Vartype(This.oProgressBar) = 'O'
				lnFiles = ADir(laFiles, '*.*')
				This.oProgressBar.nMaxValue = lnFiles
			Endif
		EndIf
		
		Return This.oDirectories
		  
	ENDPROC

	PROCEDURE getfiledatetime
		Lparameters tcFile
		
		Local lcFileName, loFile, lcExt
		
		ldFileDate = {// ::}
		lcExt = Upper(JustExt(tcFile))
		
		If InList(lcExt, 'SCX', 'VCX', 'FRX', 'MNX', 'LBX')
			Try
				Use (tcFile) Again In 0 Alias 'GF_GetMaxTimeStamp' Shared
				Select Max(TimeStamp) From GF_GetMaxTimeStamp Into Array laMaxDateTime
				ldFileDate = Ctot(This.TimeStampToDate(laMaxDateTime))
			Catch
			Finally
				If Used('GF_GetMaxTimeStamp')
					Use in ('GF_GetMaxTimeStamp')
				Endif
			Endtry
		Endif
		
		If Empty(ldFileDate)
			Try
				ldFileDate = Fdate(tcFile, 1)	
			Catch
				loFile = This.oFSO.GetFile(tcFile)
				ldFileDate = loFile.DateLastModified
			EndTry
		Endif
		
		Return ldFileDate
		
	ENDPROC

	PROCEDURE getfrxobjecttype
		Lparameters tnObjType, tnObjCode
		
		Local lcObjectType
		
		*-- Details from: http://www.dbmonster.com/Uwe/Forum.aspx/foxpro/4719/Code-meanings-for-Report-Format-ObjType-field
		
		lcObjectType = ''
		
		Do Case
			Case tnObjType = 1
				lcObjectType = 'Report'
			Case tnObjType = 2
				lcObjectType = 'Workarea'
			Case tnObjType = 3
				lcObjectType = 'Index'
			Case tnObjType = 4
				lcObjectType = 'Relation'
			Case tnObjType = 5
				lcObjectType = 'Text'
			Case tnObjType = 6
				lcObjectType = 'Line'
			Case tnObjType = 7
				lcObjectType = 'Box'
			Case tnObjType = 8
				lcObjectType = 'Field'
			Case tnObjType = 9 && Band Info
					Do Case
						Case tnObjCode = 0
							lcObjectType = 'Title'
						Case tnObjCode = 1
							lcObjectType = 'PageHeader'
						Case tnObjCode = 2
							lcObjectType = 'Column Header'
						Case tnObjCode = 3
							lcObjectType = 'Group Header'
						Case tnObjCode = 4
							lcObjectType = 'Detail Band'
						Case tnObjCode = 5
							lcObjectType = 'Group Footer'
						Case tnObjCode = 6
							lcObjectType = 'Column Footer'
						Case tnObjCode = 7
							lcObjectType = 'Page Footer'
						Case tnObjCode = 8
							lcObjectType = 'Summary'
					Endcase
			Case tnObjType = 10
				lcObjectType = 'Group'
			Case tnObjType = 17
				lcObjectType = 'Picture/OLE'
			Case tnObjType = 18
				lcObjectType = 'Variable'
			Case tnObjType = 21
				lcObjectType = 'Print Drv Setup'
			Case tnObjType = 25
				lcObjectType = 'Data Env'
			Case tnObjType = 26
				lcObjectType = 'Cursor Obj'
		EndCase
		
		Return lcObjectType 
		
		 
	ENDPROC

	PROCEDURE getprocedurestartpositions
		#DEFINE CR Chr(13)
		#DEFINE LF Chr(10)
		
		Lparameters tcCode, tcName
		
		Local loObject As 'Empty'
		Local loRegExp As 'VBScript.RegExp'
		Local loResult As 'Collection'
		Local loMatch
		Local lcClassName, lcMatch, lcName, lcPattern, lcType, lcWord1, llClassDef, llTextEndText, lnI
		Local lnStartByte, loException, loMatches, lcParentClass, lcBaseclass
		
		*
		* Original code provided by Jim R Nelson circa March 2011
		* Returns a collection indicating the beginning of each procedure / class / etc
		* Each member in the collection has these properties:
		*   .Type == 'Procedure'(Procedures and Functions)
		*         == 'Class'    (Class Definition)
		*         == 'End Class'(End of Class Definition)
		*         == 'Method'   (Procedures and Functions within a class)
		*   .StartByte == starts at zero; thus, # of chars preceding start position
		*   .Name
		*   .containingclass
		
		****************************************************************
		loRegExp = This.oRegExForProcedureStartPositions
		
		loMatches = loRegExp.Execute(tcCode)
		
		loResult = Createobject('Collection')
		
		llClassDef	  = .F. && currently within a class?
		llTextEndText = .F. && currently within a Text/EndText block?
		lcClassName	  = ''
		lcParentClass = ''
		lcBaseclass = ''
		
		For lnI = 1 To loMatches.Count
		
			loMatch = loMatches.Item(lnI - 1)
			
			With loMatch
				lnStartByte	= .FirstIndex
				lcMatch		= Chrtran(.Value, CR + LF, '  ')
				lcName		= GetWordNum(lcMatch, GetWordCount(lcMatch))
				lcWord1		= Upper(GetWordNum(lcMatch, Max(1, GetWordCount(lcMatch) - 1)))
			Endwith
		
			Do Case
				Case llTextEndText
					If 'ENDTEXT' = lcWord1
						llTextEndText = .F.
					Endif
					Loop
		
				Case llClassDef
					If 'ENDDEFINE' = lcWord1
						llClassDef	= .F.
						lcType		= 'End Class'
						lcName		= lcClassName + '.-EndDefine'
						lcClassName	= ''
						lcParentClass = ''
						lcBaseclass = ''
					Else
						lcType = 'Method'
						lcName = lcClassName + '.' + lcName
					Endif
		
				Case ' CLASS ' $ Upper(lcMatch) && Notice the spaces in ' CLASS '
					llClassDef	= .T.
					lcType		= 'Class'
					lcClassName	= GetWordNum(lcMatch, 3)
					lcParentClass = GetWordNum(lcMatch, 5)
					lcName = ''
					lcBaseclass = ''
					If This.IsBaseclass(lcParentClass)
						lcBaseclass = Lower(lcParentClass)
						lcParentClass  = ''
					Endif
		
				Case 'FUNCTION' = lcWord1
					lcType = 'Function'
					
				Otherwise
					lcType = 'Procedure'
		
			Endcase
		
			lnLFs = Occurs(Chr(10), loMatch.Value)
			lnX = 0
			* ignore leading CRLF's, and [spaces and tabs, except on the matched line]
			Do While Substr(tcCode, lnStartByte + 1, 1) $ Chr(10) + Chr(13) + Chr(32) + Chr(9) and lnX < lnLFs
				If Substr(tcCode, lnStartByte + 1, 1) = Chr(10)
					lnX = lnX + 1 
				Endif
				lnStartByte = lnStartByte + 1
			Enddo
		
			loObject = Createobject('GF_Procedure')
			
			With loObject
				.Type = lcType
				.StartByte = lnStartByte
				._Name = lcName
				._ClassName = lcClassName
				._ParentClass = lcParentClass
				._Baseclass = lcBaseclass
			Endwith
					
			Try
				loResult.Add(loObject, lcName)
			Catch To loException When loException.ErrorNo = 2062 or loException.ErrorNo = 11
				*loResult.Add(loObject, lcName + ' ' + Transform(lnStartByte))
				loResult.Add(loObject, lcName + Sys(2015))
			Catch To loException
				This.ShowErrorMsg(loException)
			Endtry
		
		
		Endfor
		
		Return loResult
		
	ENDPROC

	PROCEDURE getregexforprocedurestartpositions
		Local loRegExp as 'VBScript.RegExp'
		Local lcPattern
		
		loRegExp = CreateObject('VBScript.RegExp')
		
		With loRegExp
			.IgnoreCase	= .T.
			.Global		= .T.
			.MultiLine	= .T.
		Endwith
		
		lcPattern = 'PROC(|E|ED|EDU|EDUR|EDURE)\s+(\w|\.)+'
		lcPattern = lcPattern + '|' + 'FUNC(|T|TI|TIO|TION)\s+(\w|\.)+'
		lcPattern = lcPattern + '|' + 'DEFINE\s+CLASS\s+\w+\s+\w+\s+\w+'
		lcPattern = lcPattern + '|' + 'DEFI\s+CLAS\s+\w+'
		lcPattern = lcPattern + '|' + 'ENDD(E|EF|EFI|EFIN|EFINE)\s+'
		lcPattern = lcPattern + '|' + 'PROT(|E|EC|ECT|ECTE|ECTED)\s+\w+\s+\w+'
		lcPattern = lcPattern + '|' + 'HIDD(|E|EN)\s+\w+\s+\w+'
		
		With loRegExp
			.Pattern	= '^\s*(' + lcPattern + ')'
		Endwith 
		
		Return loRegExp
	ENDPROC

	PROCEDURE getregexforsearch
		Local loRegEx as 'VBScript.RegExp'
		
		loRegEx = Createobject ('VBScript.RegExp')
		
		Return loRegEx 
	ENDPROC

	PROCEDURE getreplaceresultobject
		Local loResult as 'Empty'
		
		loResult = CreateObject('Empty')
			AddProperty(loResult, 'lError', .f.)
			AddProperty(loResult, 'nErrorCode', 0)
			AddProperty(loResult, 'nChangeLength', 0)
			AddProperty(loResult, 'cNewCode', '')
			AddProperty(loResult, 'cReplaceLine', '')
			AddProperty(loResult, 'cTrimmedReplaceLine', '')
			AddProperty(loResult, 'lReplaced', .f.)
		Return loResult	 
	ENDPROC

	PROCEDURE getreplacerisklevel
		Lparameters toObject
			
		Local lcMatchType, lnReturn
		
		lcMatchType = toObject.MatchType
		
		lnReturn = 4 && Assume everything is very risky to start with !!!
		
		Do Case
		
			Case InList(lcMatchType, MATCHTYPE_NAME, MATCHTYPE_CONSTANT, '<Parent>', ;
									 MATCHTYPE_PROPERTY_DEF, MATCHTYPE_PROPERTY_DESC, MATCHTYPE_PROPERTY_NAME, ;
									 MATCHTYPE_PROPERTY, MATCHTYPE_PROPERTY_VALUE, ;
									 MATCHTYPE_METHOD_DEF, MATCHTYPE_METHOD_DESC, MATCHTYPE_METHOD ;
						)
		
			 			lnReturn = 3
		
			Case InList(lcMatchType, MATCHTYPE_INCLUDE_FILE, '<Expr>', '<Supexpr>', '<Picture>', '<Prompt>', '<Procedure>', ;
										'<Skipfor>', '<Message>', '<Tag>', '<Tag2>');
						Or ;
						toObject.UserField.FileType = 'DBF'
		
			 			lnReturn = 2
		
			Case InList(lcmatchtype, MATCHTYPE_CODE, MATCHTYPE_COMMENT) or;
					 (toObject.UserField.IsText and !InList(lcmatchtype, MATCHTYPE_FILENAME, MATCHTYPE_TIMESTAMP))
			 	
			 			lnReturn = 1
		
		EndCase
		
		Return lnReturn 
	ENDPROC

	PROCEDURE htmlencode
		Lparameters tcCode
		
		Local loHTML as 'htmlcode' OF 'mhhtmlcode.prg'
		Local lcHTML
		
		*-- See: http://www.universalthread.com/ViewPageNewDownload.aspx?ID=9679
		*-- From: Michael Helland - mobydikc@gmail.com
		
		loHTML = NEWOBJECT('htmlcode', 'mhhtmlcode.prg')
		lcHTML = loHtml.PrgToHtml(tcCode)
		
		Return lcHtml
		
		
		
	ENDPROC

	PROCEDURE incrementprogressbar
		Lparameters tnAmount
		
		If Vartype(This.oProgressBar) = 'O'
			This.oProgressBar.nValue = This.oProgressBar.nValue + tnAmount
		Endif
		
	ENDPROC

	PROCEDURE Init
		***#INCLUDE ..\BuildGoFish.h
		
		Lparameters tlPreserveExistingResults
		
		GOFISH_VERSION  = '0.0.001'
		
		This.cVersion = GOFISH_VERSION  && Comes from include file above
		This.oFSO = CREATEOBJECT("Scripting.FileSystemObject")
		This.oRegExForSearch = This.GetRegExForSearch()
		
		If Isnull(This.oRegExForSearch)
			Messagebox('Error creating oRegExForSearch')
			Return .F.
		Endif
		
		This.oRegExForProcedureStartPositions = This.GetRegExForProcedureStartPositions()
		If Isnull(This.oRegExForProcedureStartPositions)
			Messagebox('Error creating oRegExForProcedureStartPositions')
			Return .F.
		Endif
		
		This.BuildProjectsCollection()
		
		This.oSearchOptions = Createobject(This.cSearchOptionsClass)
		
		This.oSearchErrors = CreateObject('Collection')
		This.oReplaceErrors = CreateObject('Collection')
		
		*-- An FFC class used to generate a TimeStamp so the TimeStamp field can be updated when replacing code in a table based file.
		Try
			This.oFrxCursor = Newobject('FrxCursor', Home() + '\ffc\_FrxCursor')
		Catch
		Endtry
		
		This.PrepareForSearch()
	ENDPROC

	PROCEDURE isbaseclass		&& Returns .t. if passed string value is a native FoxPro baseclass.
		Lparameters tcString
		
		Local lcBaseclasses
		
		*-- Note: Each word below contains a space at the beginning and end of the word so the final match test
		*-- wil not return .t. for partial matches.
		
		Text to lcBaseclasses NoShow
		 CheckBox 
		 Collection 
		 Column 
		 ComboBox 
		 CommandButton 
		 CommandGroup 
		 Container 
		 Control 
		 Cursor 
		 CursorAdapter 
		 Custom 
		 DataEnvironment 
		 EditBox 
		 Empty 
		 Exception 
		 Form 
		 FormSet 
		 Grid 
		 Header 
		 Hyperlink 
		 Image 
		 Label 
		 Line 
		 ListBox 
		 OLEBound 
		 OLEContainer 
		 OptionButton 
		 OptionGroup 
		 Page 
		 PageFrame 
		 ProjectHook 
		 Relation 
		 ReportListener 
		 Separator 
		 SessionObject 
		 Shape 
		 Spinner 
		 TextBox 
		 Timer 
		 ToolBar 
		 XMLAdapter 
		 XMLField 
		 XMLTable 
		EndText
		
		Return  Upper((' ' + Alltrim(tcString) + ' ')) $ Upper(lcBaseclasses)
	ENDPROC

	PROCEDURE iscomment		&& return .t. if "*" .or. "note"
		Lparameters tcLine
		
		Local lcLine, lnCount, loMatches, loRegEx
		
		lLReturn = This.IsFullLineComment(tcLine)
		
		If llReturn = .t.
			Return .t.
		Endif
		
		
		
		*-- Look for a match BEFORE any && comment characters
		
		lnCount = Atc('&' + '&', tcLine)
		
		If lnCount > 0
			lcLine = Left(tcLine, lnCount - 1)
			loMatches = This.oRegExForSearch.Execute(lcLine)
		
			If loMatches.Count > 0
				Return .f.
			Endif
		Else
			Return .f.
		Endif
		
		
		
		 
	ENDPROC

	PROCEDURE isfiletypeincluded		&& A method that indicates if the passed filename is to be included in the search, based on the checkbox groups on the form.
		Lparameters tcFileType
		
		Local lcFileType, llReturn, loOptions
		
		lcFileType = Upper(tcFileType)
		loOptions = This.oSearchOptions
		
		If loOptions.lIncludeAllFileTypes
			Return .t.
		EndIf
		
		If !Empty(JustExt(This.oSearchOptions.cFileTemplate))
			Return This.MatchTemplate(tcFileType, JustExt(This.oSearchOptions.cFileTemplate))
		Endif
		
		Do Case
			*-- Table-based Files --------------------------------------
			Case lcFileType = 'SCX' and loOptions.lIncludeSCX
				llReturn = .t.
			Case lcFileType = 'VCX' and loOptions.lIncludeVCX
				llReturn = .t.
			Case lcFileType = 'FRX' and loOptions.lIncludeFRX
				llReturn = .t.
			Case lcFileType = 'DBC'and loOptions.lIncludeDBC
				llReturn = .t.
			Case lcFileType = 'MNX' and loOptions.lIncludeMNX
				llReturn = .t.
			Case lcFileType = 'LBX' and loOptions.lIncludeLBX
				llReturn = .t.
			Case lcFileType = 'PJX' and loOptions.lIncludePJX
				llReturn = .t.
		 
			*-- Code based files ----------------------------------
			Case lcFileType = 'PRG' and loOptions.lIncludePRG
				llReturn = .t.
			Case lcFileType = 'SPR' and loOptions.lIncludeSPR
				llReturn = .t.
			Case lcFileType = 'MPR' and loOptions.lIncludeMPR
				llReturn = .t.
			Case 'HTM' $ lcFileType and loOptions.lIncludeHTML
				llReturn = .t.
			Case lcFileType = 'H' and loOptions.lIncludeH
				llReturn = .t.
			Case lcFileType = 'ASP' and loOptions.lIncludeASP
				llReturn = .t.
			Case lcFileType = 'INI' and loOptions.lIncludeINI
				llReturn = .t.
			Case lcFileType = 'JAVA' and loOptions.lIncludeJAVA
				llReturn = .t.
			Case lcFileType = 'JSP' and loOptions.lIncludeJSP
				llReturn = .t.
			Case lcFileType = 'XML' and loOptions.lIncludeXML
				llReturn = .t.
			Case lcFileType = 'TXT' and loOptions.lIncludeTXT
				llReturn = .t.
		
		  *-- Lastly, is it match with other includes???
			Case (lcFileType $ Upper(loOptions.cOtherIncludes)) and !Empty(loOptions.cOtherIncludes)
				llReturn = .t.
			Otherwise
				llReturn = .f.
		Endcase
		
		Return llReturn  
	ENDPROC

	PROCEDURE isfulllinecomment
		Lparameters tcLine
		
		*-- See if the entire line is a comment
		Local loMatches, loRegEx
		
		loRegEx = This.GetRegExForSearch()
		loRegEx.Pattern = '^\s*(\*|NOTE|&' + '&)'
		
		loMatches = loRegEx.Execute(tcLine)
		
		If loMatches.Count > 0
			Return .t.
		Else
			Return .f.
		Endif
		 
	ENDPROC

	PROCEDURE istextfile		&& Pass in a full filename or a file extension, and it will return .t. if it is a text file, or .f. if it is a table-based file.
		Lparameters tcFile
		
		Local lcExt, llIsTextFile
		
		If Empty(tcFile)
			Return .F.
		EndIf
		
		lcExt = Upper(JustExt(tcFile))
		
		llIsTextFile = !(lcExt $ this.cTableExtensions)
		
		Return llIsTextFile
		
		
		    
	ENDPROC

	PROCEDURE loadoptions		&& Pass in XML File to load up search options.
		Lparameters tcFile
		
		Local loMy as 'My' OF 'My.vcx'
		Local laProperties[1], lcProperty
		
		If !File(tcFile)
			Return .f.
		EndIf
		
		*-- Get an array of properties that are on the SearchOptions object
		AMembers(laProperties, This.oSearchOptions, 0, 'U')
		
		*-- Load settings from file...
		loMy = Newobject('My', 'My.vcx')
		loMy.Settings.Load(tcFile)
		
		*--- Scan over Object properties, and look for a corresponding props on the My Settings object (if present)
		With loMy.Settings
		 For x = 1 to Alen(laProperties)
		 	lcProperty = laProperties[x]
		 	If Type('.' + lcProperty) <> 'U'
			 	Store Evaluate('.' + lcProperty) to ('This.oSearchOptions.' + lcProperty)
			 EndIf
		 Endfor
		Endwith
		
		*-- My.Settings stores Dates as DateTimes, so I need to convert them to just Date datatypes
		Try
			This.oSearchOptions.dTimeStampFrom = Ttod(this.oSearchOptions.dTimeStampFrom)
		Catch
			This.oSearchOptions.dTimeStampFrom = {}
		Endtry
		
		Try
			This.oSearchOptions.dTimeStampTo = Ttod(this.oSearchOptions.dTimeStampTo)
		Catch
			This.oSearchOptions.dTimeStampTo = {}
		Endtry
		
		Return .t.
		
		 
	ENDPROC

	PROCEDURE lreadytoreplace_access
		llReturn = This.nMatchLines > 0 ;
				and (!Empty(This.oSearchOptions.cReplaceExpression) or This.oSearchOptions.lAllowBlankReplace) ;
				and !This.lFileHasBeenEdited
				
		Return llReturn
				
		
	ENDPROC

	PROCEDURE ltimestampdataprovided_access
		If This.oSearchOptions.lTimeStamp and !Empty(this.oSearchOptions.dTimeStampFrom) and !Empty(this.oSearchOptions.dTimeStampTo) && If both dates are supplied
			Return .t.
		Else
			Return .f.
		EndIf
		
	ENDPROC

	PROCEDURE matchtemplate
		Lparameters tcString, tcTemplate
		
		*-- Supports normal wildcard matching with * and ?, just like old DOS matching.
		
		Local lcString, lcTemplate, llMatch, lnLength
		
		If Empty(tcTemplate) or tcTemplate = '*'
			Return .t.
		EndIf
		
		lcString= Upper(Alltrim(JustStem(tcString)))
		lcTemplate = Upper(Alltrim((tcTemplate)))
		
		llMatch = Like(lcTemplate, lcString) 
		
		Return llMatch
		
		
		* * Removed 04/08/2012 
		
		
		* 	Do Case
		* 		Case (Left(lcTemplate, 1) = '*' and Right(lcTemplate, 1) = '*')
		* 			lcTemplate = Alltrim(lcTemplate, '*')
		* 			llMatch = lcTemplate $ lcString
		* 		Case Atc('*', lcTemplate) = 0
		* 			llMatch = (lcTemplate == lcString)
		* 		Case Right(lcTemplate, 1) = '*'
		* 			lnLength = Len(lcTemplate) - 1
		* 			lcTemplate = Left(lcTemplate, lnLength)
		* 			llMatch = Left(lcString, lnLength) = lcTemplate
		* 		Case Left(lcTemplate, 1) = '*'
		* 			lnLength = Len(lcTemplate) - 1
		* 			lcTemplate= Right(lcTemplate, lnLength)
		* 			llMatch = Right(lcString, lnLength) = lcTemplate
		* 	Endcase
		
		* Return llMatch 
		
		
	ENDPROC

	PROCEDURE migratereplacedetailtable
		*-- Migrate any exitisting Replace Detail Table up to ver 4.3.022 ----
		Local lcTable, lcCsr, llSuccess
		
		lcTable = This.cReplaceDetailTable
		lcCsr = 'csrGF_ReplaceSchemaTest'
		
		If File(lcTable)
			lnSelect = Select()
			Select * From (lcTable) Where 0 = 1 Into Cursor &lcCsr
		
			If Empty(Field('Classloc', lcCsr))
				Use In (Juststem(lcTable)) && Close main table, so Alter Table in next called method can get Exclusive use
				Try
					Select 0
					Use (lcTable) Exclusive
					llSuccess = .t.
				Catch
					llSuccess = .f.
				EndTry
				
				*-- Migrate up to version 4.3.022 (circa 2012-06-30 ---------------------------
				If llSuccess
					This.RenameColumn(lcTable, 'BaseClass', 'ContainingClassBaseClass')
					This.RenameColumn(lcTable, 'ParentClass', 'ContainingClassParentClass')
					This.RenameColumn(lcTable, 'Class', 'ContainingClass')
					This.RenameColumn(lcTable, 'ObjectName', 'Name')
					This.RenameColumn(lcTable, 'ObjectClass', 'Class')
					This.RenameColumn(lcTable, 'ObjectBaseClass', 'Baseclass')
					This.AddColumn(lcTable, 'Classloc', 'C(254)')
					
					This.RenameColumn(lcTable, 'id', 'Batch_Id') && Rename this column, since it's a foreign key to the Parent table
					
					*-- Add unique Id column for each row in this child table
					This.AddColumn(lcTable, 'Pk', 'I')
					Replace Pk With Recno() All
					Alter Table JustStem(lcTable) Alter Column 'Pk' I AutoInc NextValue Reccount() + 1 Primary Key
				EndIf
				
				*-- Migrate to version 4.3.041 (2012-07-11) --------------------------------
				If llSuccess
					This.DropColumn(lcTable, 'ContainingClassBaseClass')
					This.RenameColumn(lcTable, 'ContainingClassParentClass', 'ParentClass')
				Endif
				
					
			Endif
		
			Use In &lcCsr
			Select (lnSelect)
		Endif
		
		
	ENDPROC

	PROCEDURE opentableforreplace
		Lparameters tcFileToOpen, tcCursor, tnResultId
		
		lnSelect = Select()
		
		If Used(tcCursor)
			Use in (tcCursor)
		EndIf
		
		Select 0
		
		Try
			Use (tcFileToOpen) Exclusive Alias (tcCursor)
			llReturn = .t.
		Catch
			This.SetReplaceError('Cannot open file for exlcusive use: ' + Chr(13) + Chr(13), tcFileToOpen, tnResultId)
			Select (lnSelect)
			llReturn = .f.
		EndTry
		
		Return llReturn
		
	ENDPROC

	PROCEDURE prepareforsearch
		Clear Typeahead 
		
		This.lEscPress = .F.
		This.lFileNotFound = .F.
		This.nMatchLines = 0
		This.nFileCount = 0
		This.nFilesProcessed = 0
		This.nSearchTime = 0
		This.lResultsLimitReached = .F.
		
		This.PrepareRegExForSearch()
		
		This.ClearResultsCursor()
		This.ClearResultsCollection()
		
		This.ClearReplaceSettings()
		
		This.oSearchErrors = CreateObject('Collection')
		This.oReplaceErrors = CreateObject('Collection')
		This.oDirectories = CreateObject('Collection')
		
		This.SetFilesToSkip()
		
	ENDPROC

	PROCEDURE prepareregexforreplace
		Local lcPattern
		
		lcPattern = this.oSearchOptions.cEscapedSearchExpression
		
		*If !this.oSearchOptions.lRegularExpression
		  *-- Need to trim off the pre- and post- wild card characters so we can get back to just the search phrase
			If Left(lcPattern, 2) = '.*'
			 lcPattern = Substr(lcPattern, 3)
			EndIf
		
			If Right(lcPattern, 2) = '.*'
				lcPattern = Left(lcPattern, Len(lcPattern) - 2)
			EndIf
		
		*EndIf
		
		this.oRegExForSearch.Pattern = lcPattern
		 
	ENDPROC

	PROCEDURE prepareregexforsearch
		Local lcPattern, lcRegexPattern, lcSearchExpression, loRegEx
		
		loRegEx = This.oRegExForSearch
		lcSearchExpression = This.oSearchOptions.cSearchExpression
		
		With loRegEx
		
			.IgnoreCase = ! This.oSearchOptions.lMatchCase
			.Global = .T.
			.MultiLine = .T.
		
			If This.oSearchOptions.lRegularExpression
			
				If Left(lcSearchExpression, 1) != '^'
					lcSearchExpression = '.*' + lcSearchExpression
				Endif
				
				If Right(lcSearchExpression, 1) != '$'
					lcSearchExpression = lcSearchExpression + '.*'
				Endif
		
				lcPattern = lcSearchExpression
		
			Else
		
				lcPattern = This.EscapeSearchExpression(lcSearchExpression)
		
				If This.oSearchOptions.lMatchWholeWord
					lcPattern = '.*\b' + lcPattern + '\b.*'
				Else
					lcPattern = '.*' + lcPattern + '.*'
				EndIf
				
			EndIf
		
			This.oSearchOptions.cEscapedSearchExpression = lcPattern
			
			*-- Need to add some extra markings around lcPattern to use it as the lcRegExpression
			lcRegexPattern = lcPattern 
			
			If Left(lcRegexPattern, 1) != '^'
				lcRegexPattern = '^' + lcRegexPattern
			Endif
		
			If Right(lcRegexPattern, 1) != '$'
				lcRegexPattern= lcRegexPattern + '$'
			Endif
				
			.Pattern = lcRegexPattern
		
		Endwith
		
		
		  
	ENDPROC

	PROCEDURE processinlinecomments
		Lparameters toObject
		
		Local lcCode, lcComment, lcMatchType, lcTrimmedMatchLine, lnCount, loCodeMatches, loCommentMatches
		
		lcTrimmedMatchLine = toObject.TrimmedMatchline
		lcMatchType = toObject.MatchType 
		
		lnCount = Atc('&' + '&', lcTrimmedMatchLine)
		
		If lnCount > 0 and This.oSearchOptions.lSearchInComments
			lcCode = Left(lcTrimmedMatchLine, lnCount - 1)
			lcComment = Substr(lcTrimmedMatchLine, lnCount)                           
			loCodeMatches = This.oRegExForSearch.Execute(lcCode)
			loCommentMatches = This.oRegExForSearch.Execute(lcComment)
		
			If loCodeMatches.count > 0 and loCommentMatches.count > 0
				toObject.MatchType = MATCHTYPE_COMMENT
				This.CreateResult(toObject)
				lcMatchType = toObject.UserField.MatchType && Restore to UserField MatchType for further 
			Else
				lcMatchType = Iif(loCommentMatches.count > 0, MATCHTYPE_COMMENT, toObject.MatchType)
			EndIf
		Endif
			
		toObject.MatchType = lcMatchType  
		
	ENDPROC

	PROCEDURE processsearchresult
		Lparameters toObject
		
		Local lcMatchType, lcSaveObjectName, loObject
		Local lcBaseClass, lcContainingClass, lcMethodName, lcParentClass, lcSave_Baseclass
		
		lcMatchType = toObject.UserField.MatchType
		
		*-- Store these so we can revert back after processing, becuase it's important to reset back
		*-- so any further matches in the code can be processed correctly
		With toObject.UserField
			lcSaveObjectName = ._Name
			lcSave_Baseclass = ._Baseclass
			lcBaseClass = ._Baseclass
			lcMethodName = toObject.MethodName
			lcParentClass = ._ParentClass
			lcContainingClass = .ContainingClass
		Endwith
		
		If lcMatchType # MATCHTYPE_FILENAME
			loObject = This.AssignMatchType(toObject)
		Else
			loObject = toObject
		Endif
		
		If !IsNull(loObject)
			This.CreateResult(loObject)
		Endif
		
		With toObject.UserField
			._Name = lcSaveObjectName
			._Baseclass = lcSave_Baseclass 
			._Baseclass = lcBaseClass 
			toObject.MethodName = lcMethodName 
			._ParentClass = lcParentClass 
			.ContainingClass = lcContainingClass 
		Endwith
		    
	ENDPROC

	PROCEDURE reduceprogressbarmaxvalue
		Lparameters tnReduction
		
		Try
			This.oProgressBar.nMaxValue = This.oProgressBar.nMaxValue - tnReduction
		Catch
		EndTry
		 
	ENDPROC

	PROCEDURE regexreplace
		* See: http://www.west-wind.com/wconnect/weblog/ShowEntry.blog?id=605
		************************************************************************
		* wwUtils ::  Replace
		****************************************
		***  Function: Replaces the replace string or expression for
		***            any RegEx matches found in a source string
		***    Assume: NOTE: very different from native REplace method
		***      Pass: lcSource
		***            lcRegEx
		***            lcReplace   -   String or Expression to replace with
		***            llIsExpression - if .T. lcReplace is EVAL()'d
		***
		***            Expression can use a value of lcMatch to get the
		***            current matched string value.
		***    Return: updated string
		************************************************************************
		Lparameters lcSource, lcRegEx, lcReplace, llIsExpression)
		Local loMatches, lnX, loMatch, lcRepl
		
		This.PrepareRegExForSearch()
		This.PrepareRegExForReplace()
		
		loRegex = this.oRegExForSearch
		
		If !Empty(lcRegEx)
			loRegEx.Pattern = lcRegEx
		EndIf
		
		loMatches = loRegEx.Execute(lcSource)
		
		lnCount = loMatches.Count
		
		If lnCount = 0
			Return lcSource
		Endif
		
		lcRepl = lcReplace
		
		*** Note we have to go last to first to not hose relative string indexes of the match
		For lnX = lnCount - 1 To 0 Step - 1
			loMatch = loMatches.Item(lnX)
			lcMatch = loMatch.Value
			If llIsExpression
				lcRepl = Eval(lcReplace) &&Evaluate dynamic expression each time       
			Endif
			lcSource = Stuff(lcSource, loMatch.FirstIndex + 1, loMatch.Length, lcRepl)
		Endfor
		
		Return lcSource
		
		
	ENDPROC

	PROCEDURE renamecolumn
		Lparameters tcTable, tcOldFieldName, tcNewFieldName
		
		Local lcAlias
		
		lcAlias = JustStem(tcTable)
		
		If Empty(Field(tcNewFieldName, lcAlias)) And !Empty(Field(tcOldFieldName, lcAlias))
			Try
				Alter Table (lcAlias) Rename Column (tcOldFieldName) To (tcNewFieldName)
			Catch
			Endtry
		Endif
		
		 
	ENDPROC

	PROCEDURE replacefromcurrentrow		&& This method performs a Replace operation on the current row of the passed cursor name.
		Lparameters tcCursor, tcReplaceLine
		
		Local lcColumn, lcFileToModify, lnCurrentRecno, lnMatchStart, lnProcStart, lnResultRecno, lnSelect
		Local loReplace, loResult
		
		lnSelect = Select()
		Select (tcCursor)
		lnCurrentRecno = Recno()
		
		If process = .F. && Could be that the row was previous marked for replace, and now it has been cleared.
			Replace ReplaceLine With '' In (tcCursor)
			Replace TrimmedReplaceLine With '' In (tcCursor)
			Select(lnSelect)
			Return GF_REPLACE_RECORD_IS_NOT_MARKED_FOR_REPLACE
		Endif
		
		If replaced = .t. && If it's already been processed
			Select(lnSelect)
			Return GF_REPLACE_FILE_HAS_ALREADY_BEEN_PROCESSED
		Endif
		
		If !File(filepath)
			This.SetReplaceError('File not found:', filepath, Id)
			Select(lnSelect)
			Return GF_REPLACE_FILE_NOT_FOUND
		EndIf
		
		*!*	If !Empty(tcReplaceLine) && If doing a "Replace Line", then the regular History
		*!*	 This.CreateReplaceHistoryRecord()
		*!*	Endif
		
		If This.oSearchOptions.lBackup
			llBackedUp = This.BackupFile(filepath, this.nReplaceHistoryId)
			If !llBackedUp
				Select(lnSelect)
				Return GF_REPLACE_BACKUP_ERROR
			Endif
		Endif
		
		This.PrepareRegExForSearch() && This will setup the Search part of the RegEx
		This.PrepareRegExForReplace() && This will setup the Replace part of the RegEx
		
		Scatter Name loReplace memo
		
		If This.IsTextFile(filepath)
			loResult = This.ReplaceInTextFile(loReplace, tcReplaceLine)
		Else
			loResult = This.ReplaceInTable(loReplace, tcReplaceLine)
		Endif
		
		If !loResult.lError
			*-- We must update all match result rows that are of the same source line as this row.
			*-- The reason is that search matches can result in multiple rows, and we can't process them again.
			lcFileToModify = filepath
			lnResultRecno = recno
			lnProcStart = procstart
			lnMatchStart = matchstart
			lcColumn = column
		
			Update (tcCursor) ;
				Set TrimmedReplaceLine = loResult.cTrimmedReplaceLine, ;
						ReplaceLine = loResult.cReplaceLine ;
				Where filepath == lcFileToModify And ;
							Recno = lnResultRecno And ;
							Column = lcColumn And ;
							matchstart = lnMatchStart
		
			Try
				Goto (lnCurrentRecno)
			Catch
			EndTry
		
			If loResult.lReplaced  = .t.
				This.nReplaceCount = This.nReplaceCount + 1
			Endif
		
			*-- Removed this in 4.3.014. We *do* need to re-compile.
			*If !Empty(tcReplaceLine) 
				This.Compile(filepath)
			*Endif
		
			This.UpdateCursorAfterReplace(tcCursor, loResult)
		
			lnReturn = GF_REPLACE_SUCCESS
		
		Else
		
			lnReturn = 	loResult.nErrorCode
		
		EndIf 
		
		Select (lnSelect)
		
		Return lnReturn
	ENDPROC

	PROCEDURE replaceincode
		Lparameters toReplace, tcReplaceLine
		
		* tcReplaceLine, if passed, will be used to replace the entire oringinal match line,
		* rather than using the RexEx replace with cReplaceExpression on the original line.
		
		* Notes:
		* For the Replace, the pattern on the regex must already be set (use PrepareRegExForReplace)
		* Note: Unless a full replacement line is passed in tcReplaceLine, ALL instances of the pattern will be replaced on the tcMatchLine
		
		Local lcLeft, lcLineFromFile, lcNewCode, lcReplaceExpression, lcReplaceLine, lcRight
		Local lcCode, lcMatchLine, lnLineToChangeLength, lnMatchStart, loRegEx, loResult
		
		loResult = This.GetReplaceResultObject()
		lcCode = toReplace.code
		
		lcMatchLine = Left(toReplace.matchline, toReplace.matchlen)
		
		lnMatchStart = toReplace.MatchStart
		lnLineToChangeLength = Len(lcMatchLine)
		
		lcLineFromFile = Substr(lcCode, lnMatchStart + 1, lnLineToChangeLength)
		
		If lcLineFromFile != lcMatchLine && Ensure that line from file still matches the passed in line from the orginal search!!
		 	This.SetReplaceError('Source file has changed since original search:', Alltrim(toReplace.FilePath), toReplace.Id)
		 	loResult.lError = .t.
			Return loResult
		EndIf
		
		lcLeft = Left(lcCode, lnMatchStart)
		
		*-- IMPORTANT CODE HERE... Revised code line is determined here!!!! -------------
		If Empty(tcReplaceLine)
			loRegEx = this.oRegExForSearch
			lcReplaceExpression = this.oSearchOptions.cReplaceExpression
			Do Case
				Case This.nReplaceMode = 1
					lcReplaceLine = loRegEx.Replace(lcMatchLine, lcReplaceExpression)
				Case This.nReplaceMode = 2
					lcReplaceLine = ''
				Case This.nReplaceMode = 3 and !Empty(This.cReplaceUDFCode)
					lcReplaceLine = This.ReplaceLineWithUDF(lcMatchLine)
				Otherwise
					lcReplaceLine = lcMatchLine
			Endcase
		Else
			lcReplaceLine = tcReplaceLine
		Endif
		
		lcRight = Substr(lcCode, lnMatchStart + 1 + lnLineToChangeLength)
		
		*--Added this in 4.3.014 to handle case of deleting the entire line
		If Empty(lcReplaceLine)
			lcRight = Ltrim(lcRight, 0, Chr(10)) && Need to strip off initial Chr(10) of Right hand code block
		Endif
		
		lcNewCode = lcLeft + lcReplaceLine + lcRight
		
		With loResult
			.nChangeLength = Len(lcReplaceLine) - Len(lcMatchLine)
			*--Added this in 4.3.014 to handle case of deleting the entire line
			If Empty(lcReplaceLine)
				.nChangeLength = .nChangeLength - 1 && to account for the Chr(10) we stripped off above
			Endif
			.cNewCode = lcNewCode
			.cReplaceLine = lcReplaceLine
			.cTrimmedReplaceLine = This.TrimWhiteSpace(.cReplaceLine)	
		EndWith
		
		toReplace.ReplaceLine = loResult.cReplaceLine
		toReplace.TrimmedReplaceLine = loResult.cTrimmedReplaceLine
		
		Return loResult
		
		
		    
	ENDPROC

	PROCEDURE replaceintable
		Lparameters toReplace, tcReplaceLine
		
		Local lcColumn, lcFileToModify, lcMatchLine, lcReplaceCursor, llTableWasOpened, lnMatchStart
		Local lnRecno, lnResultId, lnSelect, loResult
		
		lcFileToModify = Alltrim(toReplace.filepath)
		lcMatchLine = Left(toReplace.matchline, toReplace.matchlen)
		lnMatchStart = toReplace.matchstart
		lnResultId = toReplace.Id
		lcColumn = Alltrim(toReplace.column)
		lnRecno = toReplace.Recno
		
		lcReplaceCursor = 'ReplaceCursor'
		lnSelect = Select()
		
		loResult = This.GetReplaceResultObject()
		
		*!*	If !File(lcFileToModify)
		*!*		This.SetReplaceError('File not found:', lcFileToModify, lnResultId)
		*!*		loResult.lError = .t.
		*!*		loResult.nErrorCode = GF_REPLACE_FILE_NOT_FOUND
		*!*	Endif
		
		If !This.OpenTableForReplace(lcFileToModify, lcReplaceCursor, lnResultId)
			loResult.lError = .t.
			loResult.nErrorCode = GF_REPLACE_UNABLE_TO_USE_TABLE_FOR_REPLACE
		Else
			llTableWasOpened = .t.
		EndIf
		
		If !loResult.lError
			Try
				Goto lnRecno
			Catch
				This.SetReplaceError('Error locating record in file:', lcFileToModify, lnResultId)
				loResult.lError = .t.
				loResult.nErrorCode = GF_REPLACE_ERROR_LOCATING_RECORD_IN_FILE
			EndTry
		Endif
		
		If !loResult.lError
			toReplace.code = Evaluate(lcReplaceCursor + '.' + lcColumn)
			loResult = This.ReplaceInCode(toReplace, tcReplaceLine)
		Endif
		
		*-- Big step here... Replace code in actual record!!! (If not in Preview Mode)
		If !loResult.lError and This.oSearchOptions.lPreviewReplace = .f.
			Replace (lcColumn) With loResult.cNewCode in (lcReplaceCursor) && Update code in table
			If Type('timestamp') != 'U'
				Replace timestamp with This.oFrxCursor.getFrxTimeStamp() in (lcReplaceCursor)
			EndIf
			loResult.lReplaced  = .t.	
			This.CreateReplaceDetailRecord(toReplace)	
		Endif
			
		If llTableWasOpened
			Use && Close the table based file we opened above
		Endif
		
		Select (lnSelect)
		
		Return loResult
		        
	ENDPROC

	PROCEDURE replaceintextfile
		Lparameters toReplace, tcReplaceLine
		
		Local lcFileToModify
		
		lcFileToModify = Alltrim(toReplace.filepath)
		
		Local lcOldCode, loReseult, loResult
		
		*!*	If !File(lcFileToModify)
		*!*		This.SetReplaceError('File not found:', lcFileToModify, lnResultId)
		*!*		loResult = This.GetReplaceResultObject()
		*!*		loResult.lError = .t.
		*!*		Return loResult
		*!*	EndIf
		
		toReplace.code = FileToStr(lcFileToModify)
		loResult = This.ReplaceInCode(toReplace, tcReplaceLine)
		
		If loResult.lError or This.oSearchOptions.lPreviewReplace = .t.
			Return loResult 
		EndIf
		
		*== Big step here... About to replace old file with the new code!!!
		Try 
			If !Empty(loResult.cNewCode) && Do not dare replace the file with and empty string. Something must be wrong!
				StrToFile(loResult.cNewCode, lcFileToModify, 0) 
				loResult.lReplaced  = .t.
				This.CreateReplaceDetailRecord(toReplace)
			EndIf
		Catch
			This.SetReplaceError('Error saving file: ', lcFileToModify, toReplace.Id)
		EndTry
		
		Return loResult
		
		
		
		 
		
		                      
		
		
		              
	ENDPROC

	PROCEDURE replaceline
		Lparameters tcCursor, tnId, tcReplaceLine
		
		Local lnSelect, lnLastChar, llReturn
		
		lnSelect = Select()
		
		lcReplaceLine = tcReplaceLine
		lnLastChar = Asc(Right(lcReplaceLine, 1))
		
		If lnLastChar = 10 && Editbox will add a Chr(10) so this has to be stripped off
			lcReplaceLine = Left(lcReplaceLine, Len(lcReplaceLine) - 1)
		Endif
		
		lnLastChar = Asc(Right(lcReplaceLine, 1))
		
		If lnLastChar <> 13 and !Empty(lcReplaceLine) && Make sure user has not stripped of the Chr(13) that came with the MatchLine
			lcReplaceLine = lcReplaceLine + Chr(13)
		Endif
		
		Select(tcCursor)
		Locate For Id = tnId
		
		If Found()
		
			If replaced = .T.
				Return .t.
			Endif
		
			Replace Process With .T. In (tcCursor)
		
			This.CreateReplaceHistoryRecord()
		
			lnReturn = This.ReplaceFromCurrentRow(tcCursor, lcReplaceLine)
		
			If lnReturn >= 0
				This.UpdateReplaceHistoryRecord()
				llReturn = .t.
			Else
				llReturn = .f.
			Endif
		
		Else
		
			This.SetReplaceError('Error locating record in call to ReplaceLine() method.', '', tnId)
			llReturn = .f.
		
		EndIf
		
		Return llReturn
	ENDPROC

	PROCEDURE replacelinewithudf
		Lparameters tcMatchLine
		
		Local lcMatchLine, lcReplaceLine, llCR
		
		lcMatchLine = tcMatchLine 
		
		*-- If there is a CR at the end, pull it off before calling the UDF. Will add back later...
		If Right(tcMatchLine,1) = Chr(13)
			llCR = .t.
			lcMatchLine = Left(tcMatchLine, Len(tcMatchLine) -1) 
		Endif
		
		*-- Call the UDF ---------------
		Try
			lcReplaceLine = Execscript(This.cReplaceUDFCode, lcMatchLine)
		Catch
			lcReplaceLine = lcMatchLine && Keep the line the same if UDF failed
		Finally
		EndTry
		
		If Vartype(lcReplaceLine) <> 'C'
			lcReplaceLine = lcMatchLine
		Endif 
		
		If llCR
			lcReplaceLine = lcReplaceLine + Chr(13)
		Endif
		
		Return lcReplaceLine  
	ENDPROC

	PROCEDURE replacemarkedrows		&& This method scans of the rows in passed cursor, and calls the ReplaceFromCurrentRow() method for each marked row.
		Lparameters tcCursor
		
		Local lcFile, lcFileList, lcLastFile, lcReplaceExpression, lcSearchExpression, lnResult, lnSelect
		Local lnShift
		
		This.nReplaceCount = 0
		This.nReplaceFileCount = 0
		
		lcSearchExpression = Alltrim(This.oSearchOptions.cSearchExpression)
		lcReplaceExpression = Alltrim(This.oSearchOptions.cReplaceExpression)
		lnShift = Len(lcReplaceExpression) - Len(lcSearchExpression)
		
		This.oReplaceErrors = Createobject('Collection')
		
		If Empty(This.oSearchOptions.cReplaceExpression) And !This.oSearchOptions.lAllowBlankReplace
			This.SetReplaceError('Replace expression is blank, but ALLOW BLANK flag is not set.')
			Return .F.
		Endif
		
		lnSelect = Select()
		Select (tcCursor)
		
		This.CreateReplaceHistoryRecord()
		
		lcLastFile = ''
		
		Scan
		
			lnResult = This.ReplaceFromCurrentRow(tcCursor)
			
			*-- Skip to next file if have had any of there errors:
			If lnResult = GF_REPLACE_BACKUP_ERROR or;
				 	lnResult = GF_REPLACE_UNABLE_TO_USE_TABLE_FOR_REPLACE or ;
				 	lnResult = GF_REPLACE_FILE_NOT_FOUND	
				lcFile = filepath
				Locate for filepath <> lcFile rest
				If !Bof()
					Skip -1
				Endif
			EndIf
		
			If filepath <> lcLastFile and !Empty(lcLastFile) && If we are on a new file, then compile the previous file
				This.Compile(lcLastFile)
				lcLastFile = ''
			Endif
				
			If lnResult = GF_REPLACE_SUCCESS
				lcLastFile = Filepath
			Endif
			
		Endscan
		
		*-- Must look at compiling one last time now that loop has ended.
		If filepath <> lcLastFile and !Empty(lcLastFile) && If we are on a new file, then compile the previous file
			This.Compile(lcLastFile)
		Endif
		
		
		This.UpdateReplaceHistoryRecord()
		
		Select (lnSelect)
		
		This.ShowWaitMessage('Replace Done.')
		
		    
	ENDPROC

	PROCEDURE restoredefaultdir
		Cd (this.cInitialDefaultDir)
	ENDPROC

	PROCEDURE saveoptions
		Lparameters tcFile
		 
		Local loMy as 'My' OF 'My.vcx'
		Local laProperties[1], lcProperty
		
		loMy = Newobject('My', 'My.vcx')
		
		AMembers(laProperties, This.oSearchOptions, 0, 'U')
		
		With loMy.Settings
		 
		 For x = 1 to Alen(laProperties)
		 	lcProperty = laProperties[x]
		 	If !InList(lcProperty, '_MEMBERDATA', 'CPROJECTS')
			 	.Add(lcProperty, Evaluate('This.oSearchOptions.' + lcProperty))
			EndIf
		 Endfor
		
		.Save(tcFile)
		
		Endwith
		  
	ENDPROC

	PROCEDURE searchfinished		&& Called by SearchInPath() and SearchInProject() once they are finished. This will update some class properties, end the timer, and other cleanup stuff.
		Lparameters tnSelect
		
		This.lResultsLimitReached = (This.nMatchLines >= This.oSearchOptions.nMaxResults)
		
		This.EndTimer()
		
		Inkey(.10) && Delay is needed to allow Progress Bar to fully update before it disappears.
		This.StopProgressBar()
		
		If This.nMatchLines = 0 And This.oSearchOptions.lShowNoMatchesMessage and !This.lEscPress
			Messagebox('No matches found', 64, 'GoFish')
		Endif
		
		Select (tnSelect)
		
		
	ENDPROC

	PROCEDURE searchincode		&& Find text within text-based files like PRG,SPR,MPR, etc.
		Lparameters tcCode, tuUserField, tlHasProcedures
		
		Local loObject as 'GF_SearchResult'
		Local lcErrorMessage, llScxVcx, lnMatchCount, lnSelect, loMatch, loMatches, loProcedure
		Local loProcedureStartPositions, lcMatchType
		
		lnSelect = Select()
		
		If Empty(tcCode)
			Return 0
		Endif
		*-- Be sure that oRegExForSearch has been setup... Use This.PrepareRegExForSearch() or roll-your-own
		Try
			loMatches = This.oRegExForSearch.Execute(tcCode)
		Catch
		EndTry
		
		If Type('loMatches') = 'O'
			lnMatchCount = loMatches.Count
		Else
			lcErrorMessage = 'Error processing regular expression.    ' + This.oRegExForSearch.Pattern
			this.SetSearchError(lcErrorMessage)
		  Return -1
		EndIf
		
		If lnMatchCount > 0
		
			loProcedureStartPositions = Iif(tlHasProcedures, this.GetProcedureStartPositions(tcCode), .null.)
		
			For Each loMatch In loMatches FOXOBJECT
		
				If tlHasProcedures and !This.oSearchOptions.lSearchInComments and This.IsComment(loMatch.Value)
					Loop
				EndIf
				loProcedure = this.FindProcedureForMatch(loProcedureStartPositions, loMatch.firstindex)
				loObject = Createobject('GF_SearchResult')
				
				With loObject
					.UserField = tuUserField 
					.oMatch = loMatch
					.oProcedure = loProcedure
		
					.Type = Proper(.oProcedure.Type)
					*.ContainingClass =	.oProcedure._ClassName	&& Not used on this object. This line to be deleted after testing. (2012-07-11)
					.MethodName = .oProcedure._Name
					.ProcStart = .oProcedure.StartByte
		
					.MatchLine = .oMatch.Value
					.MatchStart = .oMatch.firstindex
					.MatchLen = Len(.oMatch.Value)
		
					If tlHasProcedures 
						.MatchType = loProcedure.type && Use what was determined by call to FindProcedureForMatch()
						tuUserField.MatchType = loProcedure.type
					Else
						.MatchType = tuUserField.MatchType && Use what was passed.
					Endif
		
					.Code = Iif(this.oSearchOptions.lStoreCode, tcCode, '')
				EndWith		
				
			This.ProcessSearchResult(loObject)
		
			EndFor
		
		Endif
		
		Select(lnSelect)
		
		Return lnMatchCount   
	ENDPROC

	PROCEDURE searchinfile		&& Both ProcessProject() and ProcessPath() pass their filenames into this method to have it processed.
		Lparameters tcFile, tlForce
		
		*-- Only searches passed file if its file ext is marked for inclusion (i.e. lIncludeSCX)
		*-- Optionally, pass tlForce = .t. to force the file to be searched.
		Local lnMatchCount
		
			If Lastkey() = 27 or Inkey() = 27
				This.lEscPress = .T.
				Clear Typeahead
				Return 0
			Endif
		
			*-- See if the filename matches the File template filter (if one is set) ----
			If !Empty(This.oSearchOptions.cFileTemplate)
				If !This.MatchTemplate(JustFname(tcFile), JustStem(JustFname(This.oSearchOptions.cFileTemplate)))
					This.ReduceProgressBarMaxValue(1)
					Return 0
				Endif
			Endif
		
			If This.FilesToSkip(tcFile)
				Return 0									
			EndIf
		
			If !This.IsFileTypeIncluded(JustExt(tcFile)) and !tlForce
				*This.ReduceProgressBarMaxValue(1)
				Return 0
			EndIf
			
			If !File(tcFile)
				this.lFileNotFound = .t.
				this.SetSearchError('File not found: ' + tcFile)
				*This.ReduceProgressBarMaxValue(1)
				Return 0
			EndIf
		
			This.ShowWaitMessage('Processing file: ' + tcFile)
		
			*-- Look for a match on the file name ----------------------
			***lnFileNameMatchCount = This.SearchInFileName(tcFile)
		
			***If lnFileNameMatchCount < 0
			***	Return lnFileNameMatchCount 
			***Endif
			
			llTextFile = This.IsTextFile(tcFile)
			
			*-- Do not search inside of file if we are only looking at timestamps and have and empty string
			* If llTextFile and This.oSearchOptions.lTimeStamp and Empty(This.oSearchOptions.cSearchExpression)
			* 	This.nFilesProcessed = This.nFilesProcessed + 1 
			* 	This.nFileCount = This.nFileCount + 1 	
			* 	Return lnFileNameMatchCount 
			* Endif
		
			*-- Look for a match within the file contents ----------------------
			If llTextFile
				lnMatchCount = This.SearchInTextFile(tcFile)
			Else
				lnMatchCount = This.SearchInTable(tcFile)
			EndIf
		
			This.nFilesProcessed = This.nFilesProcessed + 1 
		
			***If lnMatchCount < 0
			***	Return lnMatchCount 
			***Endif
			
			*-- Count number of files that had a match by either search above ---
			***If lnMatchCount > 0 or lnFileNameMatchCount > 0
				this.nFileCount = this.nFileCount + 1 
			***EndIf		
			
			*** Return lnMatchCount + lnFileNameMatchCount
			
			Return 1
			
		 	
	ENDPROC

	PROCEDURE searchinfilename
		Lparameters tcFile
		
		Local loFileResultObject as 'GF_FileResult'
		Local loSearchResultObject as 'GF_SearchResult'
		Local lcCode, ldFileDate, lnMatchCount, lnSelect, llHasMethods
		
		lnSelect = Select()
		
		If !File(tcFile)
			this.lFileNotFound = .t.
			this.SetSearchError('File not found: ' + tcFile)
			Return 0
		EndIf
		
		ldFileDate = This.GetFileDateTime(tcFile)
		
		ldFromDate = Evl(this.oSearchOptions.dTimeStampFrom, {^1900-01-01})
		ldToDate = Evl(this.oSearchOptions.dTimeStampTo, {^9999-01-01})
		ldToDate = ldToDate + 1 &&86400 && Must bump into to next day, since TimeStamp from table has time on it
		
		If This.oSearchOptions.lTimeStamp and !Between(ldFileDate, ldFromDate, ldToDate)
			Return 0
		Endif
		
		*-- Be sure that oRegExForSearch has been setup... Use This.PrepareRegExForSearch() or roll-your-own
		Try
			loMatches = This.oRegExForSearch.Execute(JustFname(tcFile))
		Catch
		EndTry
		
		If Type('loMatches') = 'O'
			lnMatchCount = loMatches.Count
		Else
			lcErrorMessage = 'Error processing regular expression.    ' + This.oRegExForSearch.Pattern
			this.SetSearchError(lcErrorMessage)
		  Return -1
		EndIf
		
		If lnMatchCount = 0 and !Empty(This.oSearchOptions.cSearchExpression)
			Return 0
		Endif
		
		loFileResultObject = Createobject('GF_FileResult')	&& This custom class has all the properties that must be populated if you want to
																							&& have a cursor created
		With loFileResultObject
			.FileName = Justfname(tcFile)
			.FilePath = tcFile
			.MatchType = MATCHTYPE_FILENAME
			.FileType = Upper(JustExt(tcFile))
			.TimeStamp = ldFileDate
		EndWith
		
		loSearchResultObject = Createobject('GF_SearchResult')
		loSearchResultObject.UserField = loFileResultObject
		loSearchResultObject.MatchType = MATCHTYPE_FILENAME
		
		If This.IsTextFile(tcFile)
			loSearchResultObject.Code = FileToStr(tcFile)
		Endif
				
		This.ProcessSearchResult(loSearchResultObject)
		
		Select (lnSelect)
		
		Return 1
		
					   
	ENDPROC

	PROCEDURE searchinpath
		Lparameters tcPath
		
		Local lcDirectory, lcFile, lcFileFilter, lcFilename, lnFileCount, lnReturn, lnSelect, j
		
		lnSelect = Select()
		
		If Empty(tcPath)
			This.SetSearchError('Path parameter [' + tcPath + '] is empty in call to SearchInPath()')
			Return 0
		Endif
		
		This.oSearchOptions.cPath = tcPath
		
		This.StoreInitialDefaultDir()
		
		If !This.ChangeCurrentDir(tcPath) && If there was a problem CD-ing into the starting path
			This.RestoreDefaultDir()
			Return -1
		EndIf
			
		This.PrepareForSearch()
		This.StartTimer()
		
		lnReturn = 1 && Assume success, testing below will set negative if there are errors
		
		This.ShowWaitMessage('Scanning directory...')
		
		If Vartype(This.oProgressBar) = 'O'
			This.oProgressBar.nMaxValue = 0
		EndIf
		
		This.StartProgressBar(0)
		
		This.oDirectories = This.GetDirectories(tcPath, This.oSearchOptions.lIncludeSubdirectories)
		
		If This.lEscPress = .t.
			This.SearchFinished(lnSelect)
			Return 0
		Endif
		
		ChDir (tcPath) && Must go back, since above call to BuildDirList prolly changed our directory!
		
		If Vartype(This.oProgressBar) = 'O'
			This.StartProgressBar(This.oProgressBar.nMaxValue)
		EndIf
		
		lnTotalFileCount = 0
		
		For Each lcDirectory in This.oDirectories
		
					lcFileFilter = Addbs(lcDirectory) + '*.*'
					
					If Adir(laTemp, lcFileFilter) = 0 && 0 means no files in the Dir
						Loop
					Endif
		
					Asort(laTemp)
					
					lnFileCount = Alen(laTemp) / 5 && The number of files that match the filter criteria for this pass
							
					For j = 1 To lnFileCount
							lcFilename = laTemp(j, 1) && Just the name and ext, no path info
							lcFile = Addbs(lcDirectory) + lcFilename && path + filename
							lnReturn = This.SearchInFile(lcFile)
		
							lnTotalFileCount = lnTotalFileCount + 1
							This.UpdateProgressBar(lnTotalFileCount)
		
							If lnReturn < 0 or This.lEscPress = .t. or This.nMatchLines >= this.oSearchOptions.nMaxResults
								Exit
							EndIf									
					EndFor
					
					If lnReturn < 0 or This.lEscPress = .t. or This.nMatchLines >= this.oSearchOptions.nMaxResults
						Exit
					EndIf		
		EndFor
		
		This.SearchFinished(lnSelect)
		
		This.RestoreDefaultDir()
		
		If lnReturn >= 0
			Return 1
		Else
			Return lnReturn
		Endif
		
			
		      
	ENDPROC

	PROCEDURE searchinproject
		Lparameters tcProject
		
		Local laProjectFiles[1], lcFile, lcProjectAlias, lcProjectPath, lnReturn, lnSelect, n
		
		lnSelect = Select()
		
		lcProjectPath = Addbs(JustPath(Alltrim(tcProject)))
		lcProjectAlias = 'GF_ProjectSearch'
		
		This.oSearchOptions.cProject = tcProject
		
		If Empty(tcProject)
			This.SetSearchError('Project parameter [' + tcProject + '] is empty in call to SearchInProject().')
			Return 0
		EndIf
		
		If !File(tcProject)
			This.SetSearchError('Project file [' + tcProject + '] not found in call to SearchInProject().')
			Return 0
		EndIf
		
		Try && Attempt to open Project.PJX in a cursor...
			Select 0
			Use (tcProject) Again Shared Alias &lcProjectAlias
			lnReturn = 1
		Catch
			lnReturn = -2
		Endtry
		
		If lnReturn = -2
			This.SetSearchError('Cannot open project file[' + tcProject + ']')
			This.SearchFinished(lnSelect)
			Return lnReturn
		Endif
		
		Select Name, Type ;
		 From (lcProjectAlias) ;
		 Where Type $ 'EHKMPRVBdTxD' And ;
		   Not Deleted() ;
		   And !(Upper(JustExt(name)) $ This.cGraphicsExtensions) ;
		 Order By type ;
		 Into Array laProjectFiles
		
		If Type('laProjectFiles') = 'L'
			This.SearchFinished(lnSelect)
			Return 1
		EndIf
		
		Use In Alias (lcProjectAlias)
		
		This.PrepareForSearch()
		This.StartTimer()
		This.StartProgressBar(Alen(laProjectFiles) / 2.0)
		
		For n = 1 To Alen(laProjectFiles) Step 2
		
			lcFile = laProjectFiles(n)
			lcFile = FullPath(lcFile, lcProjectPath)
			lcFile = Strtran(lcFile, Chr(0), '') && Strip out junk char from the end
			
			If This.oSearchOptions.lLimitToProjectFolder
				If !(Upper(lcProjectPath) $ Upper(Addbs(JustPath(lcFile))))
					Loop
				Endif
			Endif
		
			lnReturn = this.SearchInFile(lcFile)
		
			This.UpdateProgressBar(This.nFilesProcessed)
			
			If (lnReturn < 0) or this.lEscPress = .t. or This.nMatchLines >= This.oSearchOptions.nMaxResults
				Exit
			EndIf
			
		EndFor
		
		This.SearchFinished(lnSelect)
		
		If lnReturn >= 0
			Return 1
		Else
			Return lnReturn
		Endif
		
			
		    
	ENDPROC

	PROCEDURE searchintable		&& Performs a search on a table-based file like a VCX, SCX, FRX, etc.
		Lparameters tcFile &&, tcSearchExpression &&, zcltype, zfilename
		
		Local loFileResultObject as 'GF_FileResult'
		Local loSearchResultObject as 'GF_SearchResult'
		Local laMaxTimeStamp[1], laParent[1], lcCode, lcDataType, lcDeleted, lcExt, lcField, lcFieldSource
		Local lcFormClass, lcFormClassloc, lcFormName, lcName, lcObjectType, lcParent, lcParentName
		Local lcProject, lcSearchExpression, ldFromDate, ldMaxTimeStamp, ldToDate, llContinueError
		Local llHasMethods, llProcessThisMatch, llScxVcx, lnEndColumn, lnMatchCount, lnParentId, lnSelect
		Local lnStart, lnStartColumn, lnTotalMatches, lcClass, llLocateError 
		
		lnSelect = Select()
		
		lnMatchCount = 0
		lnTotalMatches = 0
		lcExt = Upper(JustExt(tcFile))
		lcProject = This.oSearchOptions.cProject
		
		lcSearchExpression = Upper(Alltrim(this.oSearchOptions.cSearchExpression))
		
		*  On Error *
		
		Use (tcFile) Again Shared Alias 'GF_TableSearch' In Select('GF_TableSearch')
		
		If !Used('GF_TableSearch')
			On Error
			This.SetSearchError('Cannot open file: ' + Alltrim(tcFile) + ', therefore, skipping it.', 16, 'File Error')
			Return 0
		Else
			Select('GF_TableSearch')
			
			*=======================================================================================
			*-- Call custom Processor, if present, then exit out...
			Local loCustomProcessor, loData
			If Vartype(This.oCustomProcessor) = 'O'
				loCustomProcessor = This.oCustomProcessor
				If This.lSearchOncePerVCX
					Scatter Name m.loData Memo
					AddProperty(m.loData, 'cFilename', tcFile)
					m.loCustomProcessor.Process(m.loData)
				Else
					If Pemstatus(m.loCustomProcessor, 'Process', 5)
						Scan
							Scatter Name m.loData Memo
							AddProperty(m.loData, 'cFilename', tcFile)
							m.loCustomProcessor.Process(m.loData)
						Endscan
					Endif
				Endif
				Return 0
			Endif
				*=======================================================================================
			
			
			If lcExt = 'SCX'
				Locate for baseclass = 'form'
				lcFormName = objname
				lcFormClass = class
				lcFormClassloc = classloc
			Endif
			
		EndIf
		
		If This.oSearchOptions.lTimeStamp and Type('timestamp') = 'U'
			Use in 'GF_TableSearch'
			Return 0
		Endif
		
		On Error
		
		This.ShowWaitMessage('Searching File: ' + tcFile)
		
		lnEndColumn = 255
		
		Do Case
			Case 'VCX' $ lcExt
				lnStartColumn = 4
			Case 'SCX' $ lcExt
				lnStartColumn = 4
				*lnEndColumn = 12
			Case 'FRX' = lcExt
				lnStartColumn = 3 && Newer reports could start at col 6, but older reports can have text data starting in column 3
				*lnEndColumn = 21
				If Len(Field('timestamp', 'GF_TableSearch')) > 0 && Some really old reports may not have this field.
					Select Max(TimeStamp) From 'GF_TableSearch' Into Array laMaxTimeStamp
				Else
					laMaxTimeStamp = {}
				Endif
				ldMaxTimeStamp = Ctot(This.TimeStampToDate(laMaxTimeStamp))
			Case 'DBC' = lcExt
				lnStartColumn = 3
				*lnEndColumn = 6
			Case 'MNX' = lcExt
				lnStartColumn = 1
			Otherwise
				lnStartColumn = 1
		EndCase
		
		
		lcDeleted = Set('Deleted')
		Set Deleted On
		
		*-- Scan across all table columns looking for matches on each row
		*--	See: http://fox.wikis.com/wc.dll?Wiki~VFPVcxStructure for details about scx/vcx columns
		*-- See: http://mattslay.com/foxpro-report-frx-table-structure for details about FRX structure
		
		For ii = lnStartColumn To lnEndColumn Step 1
			Goto top
			lcField = Upper(Field(ii))
			llLocateError = .f.
			
			If Empty(lcField)
				Exit
			EndIf
		
			If  !Type(lcField) $ 'CM' Or ; && If not a character or Memo field
					('TAG' $ lcField And lcExt != 'FRX') Or ;
					InList(lcField, 'OBJCODE', 'OBJECT', 'SYMBOLS')
				Loop
			EndIf
		
			If lcExt = 'DBC'
				lcObjectType = Alltrim(Upper(objecttype))
				If Type('objectname') = 'U'&& or;
				   *'OBJECT' $ Upper(objectname) or;
				   InList(lcObjectType, 'FIELD', 'VIEW', 'TABLE')
					Loop
				Endif
			Endif
		
			*-- This is an important speed part of GoFish... If the user is not using a regular expression, then we
			*-- can use the Locate command to make a quick look for a match anywhere in this column. We will handle the
			*-- whole word part later on in the code, but a quick partial match hit helps us skips rows that have not
			*-- match at all.
			*-- If we find a match, we process it futher and then call Continue to look for the next partial and repeat.
			*-- This logic is not used if we are doing a Reg Ex search.
			If !this.oSearchOptions.lRegularExpression
				If This.oSearchOptions.lTimeStamp
					ldFromDate = Evl(this.oSearchOptions.dTimeStampFrom, {^1900-01-01})
					ldToDate = Evl(this.oSearchOptions.dTimeStampTo, {^9999-01-01})
					ldToDate = ldToDate + 1 &&86400 && Must bump into to next day, since TimeStamp from table has time on it
		
					Locate For Between(Ctot(This.TimeStampToDate(timestamp)), ldFromDate, ldToDate) NoOptimize
														 
					If !Found() && If doing a TimeStmp search and we did not find a match, we can skip out of this file
						Exit 
					EndIf
				Else
					Try
						If This.oSearchOptions.nSearchMode = GF_SEARCH_MODE_LIKE
							Locate For Likec('*' + Upper(lcSearchExpression) + '*', Upper(Evaluate(lcField))) NoOptimize
						Else
							Locate For Upper(lcSearchExpression) $ Upper(Evaluate(lcField)) NoOptimize
						Endif
					Catch
						This.SetSearchError('Error scanning through table [' + tcFile + ']. File may be corrupt.')
						llLocateError = .t.
					Finally
					Endtry
				EndIf
		
				If !Found() or llLocateError = .t.
					Loop && Loop to next column
				EndIf
		
			EndIf
		
		Do while !Eof()  
			
				lnMatchCount = 0
				loFileResultObject = Createobject('GF_FileResult')	&& This custom class has all the properties that must be populated if you want to
				llProcessThisMatch = .t.														&& have a cursor created
				llScxVcx = InList(lcExt, 'VCX', 'SCX')
				lcCode = Evaluate(lcField)
		
				With loFileResultObject
						.Process = .f.
						.FileName = Justfname(tcFile)
						.FilePath = tcFile
						.MatchType = Proper(lcField)
						.FileType = Upper(lcExt)
						.Column = lcField
						.IsText = .f.
						.Recno = Recno()
						.TimeStamp = Iif(Type('timestamp') != 'U', Ctot(This.TimeStampToDate(timestamp)), {// :: AM})
			
						lcClass = Iif(Type('class') != 'U', class, '')
						.ContainingClass = lcClass
						._ParentClass = lcClass
						._Baseclass = Iif(Type('baseclass') != 'U', baseclass, '')
						.Classloc = Iif(Type('classloc') != 'U', classloc, '')
			
						lcParent = Iif(Type('parent') != 'U', parent, '')
						lcName = Iif(Type('objname') != 'U', objname, '')
						._Name = Alltrim(lcParent + '.' + lcName, '.')
								
								Do Case
									Case lcExt = 'SCX'
		
										._Class = ''
										
										If !Empty(lcParent)
											._Name = Strtran(._Name, lcFormName + '.', '', 1, 1) && Trim off Form name from the beginning of object name
										Else
											._Name = ''
										EndIf
		
									Case lcExt = 'VCX'
										
										If !Empty(lcParent)
											._Class = GetWordNum(lcParent, 1, '.')
										Else
											._Class = Alltrim(objname)
											._Name = ''
										EndIf
										
									Case lcExt = 'FRX'
										._Name = name
										._Class = This.GetFrxObjectType(objtype, objcode)
										If Empty(.TimeStamp)
											.TimeStamp = ldMaxTimeStamp
										Endif
								
									Case lcExt = 'DBC'
										._Name = Alltrim(objectname)
										._Class = Alltrim(objecttype)
										
										Do Case
										
											Case ._Class = 'Database' and lcField = 'OBJECTNAME'
												*lcCode = '' && Will cause this match to be skipped. Don't want to record these matches.
										
											Case ._Class = 'Table'
												*lcCode = ._Class + '.dbf' && The name of the Table attached to the DBC
												lcCode = This.CleanUpBinaryString(lcCode)  && The SQL statement that makes up the View
		
											Case ._Class = 'View'
												lnStart = Atc('Select', lcCode)
												lcCode = Substr(lcCode, lnStart)
												lcCode = This.CleanUpBinaryString(lcCode, .t.)  && The SQL statement that makes up the View
											
											Case ._Class = 'Field' && Fields can be part of Tables or Views
												*-- Get some info about the parent of this field
												lnParentId = parentid
												Select objecttype, objectname from (tcFile) where objectid = lnParentId into Array laParent
												lcParentName = Alltrim(laParent[2])
											
												*-- Parse the field into a field name and field source
												lnStart = Atc('#', lcCode)
												lcCode = Substr(lcCode, lnStart + 1)
												lcCode = This.CleanUpBinaryString(lcCode)	
												
												lcFieldSource = Alltrim(GetWordNum(lcCode, 1))
												lcDataType = Substr(Alltrim(GetWordNum(lcCode, 2)), 2)
												
												If lcFieldSource = '0'
													lcFieldSource = '[Table alias in query]'
													lcDataType = ''
												Endif
												
												If !Empty(lcDataType)
													lcCode = lcParentName + ' references ' + lcFieldSource + ' (data type: ' + lcDataType + ')'
													.MatchType = 'Field Source'
												Else
													lcCode = lcParentName + '.' + lcFieldSource
													.MatchType = Alltrim(laParent[1]) + ' Field'
												Endif
												
												._Class = .MatchType
											
										Endcase
								Endcase
						*EndIf
						
						*If Alltrim(Upper(._ParentClass)) = Alltrim(Upper(._Baseclass))
						*	._ParentClass = ''
						*EndIf
						
						*-- Here is where we can skip the processing of certain record that we want to ignore, even though we found a match in them...
						If (Empty(lcClass) and lcExt = 'VCX') Or; && This is the ending row of a Class def in a vcx. Need to skip over it.
							 (lcField = 'TAG2' and lcExt = 'FRX' and Recno() = 1) && Tag2 on first record in a FRX is binary and I want to skip it
								llProcessThisMatch = .f.
						EndIf
						
				EndWith
		
				If This.oSearchOptions.lTimeStamp and !Between(Ctot(This.TimeStampToDate(timestamp)), ldFromDate, ldToDate)
						llProcessThisMatch = .f.
				Endif
		
				If llProcessThisMatch = .t.
					If !Empty(this.oSearchOptions.cSearchExpression)
						*lcCode = Evaluate(lcField)
						llHasMethods = Upper(lcField) = 'METHODS' or;
													 lcExt = 'FRX' and Upper(lcField) = 'TAG' and Upper(name) = 'DATAENVIRONMENT'
						lnMatchCount = This.SearchInCode(lcCode, loFileResultObject, llHasMethods)
					Else
					  * Can't search since there is no cSearchExpression, so we just log the file as a result.
					  * This handles TimeStamp searches, where the cSearchExpression is empty
						loSearchResultObject = Createobject('GF_SearchResult')
						loSearchResultObject.Code = Iif(Type('properties') != 'U', properties, '')
						loSearchResultObject.Code = loSearchResultObject.Code + CR + Iif(Type('methods') != 'U', methods, '')
						loSearchResultObject.UserField = loFileResultObject
						
						If lcExt = 'FRX'
							loSearchResultObject.MatchLine = Expr
							loSearchResultObject.TrimmedMatchLine = Expr
						Endif
						
						This.ProcessSearchResult(loSearchResultObject)
						
						ii = 1000 && To end the outer for loop when the Do loop ends
						lnMatchCount = lnMatchCount + 1
						EndIf
				EndIf
				
				If lnMatchCount < 0 && There was an error in above call, need to exit
					Exit
				Else
					lnTotalMatches = lnTotalMatches + lnMatchCount		
				EndIf
		
		
				If !this.oSearchOptions.lRegularExpression
					Try
						Continue
					Catch
						This.SetSearchError('Error scanning through table [' + tcFile + ']. File may be corrupt.')
						llContinueError = .t.
					Finally
					Endtry
					
					If llContinueError = .t.
						Exit
					Endif
					
					
				Else
					Skip 1
				EndIf
				
			EndDo
		
			If lnMatchCount < 0 && There was an error in above call
				Exit
			EndIf
		
		EndFor
		
		Set Deleted &lcDeleted
		
		Use in 'GF_TableSearch'
		
		Select (lnSelect)
		
		If lnMatchCount < 0
			Return lnMatchCount
		Else
			Return lnTotalMatches
		EndIf
		         
	ENDPROC

	PROCEDURE searchintextfile
		Lparameters tcFile
		
		Local loFileResultObject as 'GF_FileResult'
		Local loSearchResultObject as 'GF_SearchResult'
		Local lcCode, ldFileDate, lnMatchCount, lnSelect, llHasMethods
		
		lnSelect = Select()
		
		If !File(tcFile)
			this.lFileNotFound = .t.
			this.SetSearchError('File not found: ' + tcFile)
			Return 0
		EndIf
		
		ldFileDate = This.GetFileDateTime(tcFile)
		
		ldFromDate = Evl(this.oSearchOptions.dTimeStampFrom, {^1900-01-01})
		ldToDate = Evl(this.oSearchOptions.dTimeStampTo, {^9999-01-01})
		ldToDate = ldToDate + 1&&86400 && Must bump into to next day, since TimeStamp from table has time on it
		
		If This.oSearchOptions.lTimeStamp and !Between(ldFileDate, ldFromDate, ldToDate)
			Return 0
		EndIf
		
		*=======================================================================================
		* Special code of oCustomProcessor
		*=======================================================================================
		If Vartype(This.oCustomProcessor) = 'O'
				lcCode = FileToStr(tcFile) && File could be in use by some other app and can't be read in
				loData = CreateObject('Empty')
				AddProperty(loData, 'Code', lcCode)
				AddProperty(loData, 'cFilename', tcFile)
				This.oCustomProcessor.Process(loData)
				lnReturn = 1
			Return lnReturn
		Endif
		*=======================================================================================
		
		
		loFileResultObject = Createobject('GF_FileResult')	&& This custom class has all the properties that must be populated if you want to
		
		With loFileResultObject
			.FileName = Justfname(tcFile)
			.FilePath = tcFile
			.MatchType = Proper(JustExt(tcFile))
			.FileType = Upper(JustExt(tcFile))
			.IsText = .t.	
			.TimeStamp = ldFileDate
		EndWith
					
		If !Empty(this.oSearchOptions.cSearchExpression)
			Try
				lcCode = FileToStr(tcFile) && File could be in use by some other app and can't be read in
				llReadFile = .t.
			Catch
				This.SetSearchError('Could not open file [' + tcFile + '] for reading.')
				llReadFile = .f.
			Endtry
			If !llReadFile
				Select (lnSelect)
				Return 0
			Endif	
		
			llHasMethods = InList(Upper(loFileResultObject.MatchType), 'PRG', 'MPR')
			lnMatchCount = This.SearchInCode(lcCode, loFileResultObject, llHasMethods)
		Else
		  * Can't search since there is no cSearchExpression, so we just log the file as a result.
		  * This handles TimeStamp searches, where the cSearchExpression is empty
			loSearchResultObject = Createobject('GF_SearchResult')
			loSearchResultObject.UserField = loFileResultObject
				
			This.ProcessSearchResult(loSearchResultObject)
			lnMatchCount = 1
		EndIf
		
		Select (lnSelect)
		
		Return lnMatchCount
		
					   
	ENDPROC

	PROCEDURE setfilestoskip
		*-- Read a user file set the the cFilesToSkip property
		
		Local lcExclusionFile, lcFilesToSkip
		
		lcFilesToSkip = ''
		
		lcExclusionFile = This.cFilesToSkipFile
		
		If File(lcExclusionFile) and This.oSearchOptions.lSkipFiles
			lcFilesToSkip = Chr(13) + Chrtran(FileToStr(lcExclusionFile), Chr(10), '') + Chr(13)
		Endif
		
		This.cFilesToSkip = Upper(lcFilesToSkip + Chr(13) + '_command.prg' + Chr(13))
		
		
		
		
	ENDPROC

	PROCEDURE setproject
		Lparameters tcProject
		
		Local lcProject, llReturn
		
		lcProject = Lower(Evl(tcProject, ''))
		
		If Empty(lcProject)
			Return .t.
		Endif
		
		If !('.pjx' $ lcProject)
			lcProject = lcProject+ '.pjx'
		EndIf
		
		If File(lcProject)
			This.AddProject(lcProject)
			This.oSearchOptions.cProject = lcProject
			llReturn = .t.
		Else
			This.oSearchOptions.cProject = ''
			This.SetSearchError('Project not found [' + lcProject + '] in call to SetProject() method.')
			llReturn = .f.
		EndIf
		
		Return llReturn
		
		  
	ENDPROC

	PROCEDURE setreplaceerror
		Lparameters tcErrorMessage, tcFile, tnResultId, tnDialogBoxType, tcTitle
		
		Local lcErrorMessage, lcFile, lnResultId
		
		lcFile = Alltrim(Evl(tcFile, 'None'))
		lnResultId = Evl(tnResultId, 0)
		
		lcResultId = Iif(lnResultId = 0, 'None', Alltrim(Str(lnResultId)))
		
		lcErrorMessage = tcErrorMessage + Space(4) + ;
										'[File: ' + lcFile + ']' + Space(4) +;
										'[Result Id: ' + lcResultId + ']' 
										
		this.ShowError(lcErrorMessage, tnDialogBoxType, tcTitle)
		
		This.oReplaceErrors.Add(lcErrorMessage)   
	ENDPROC

	PROCEDURE setsearcherror
		Lparameters tcErrorMessage, tnDialogBoxType, tcTitle
		
		this.ShowError(tcErrorMessage, tnDialogBoxType, tcTitle)
		
		This.oSearchErrors.Add(tcErrorMessage) 
	ENDPROC

	PROCEDURE showerror
		Lparameters tcErrorMessage, tnDialogBoxType, tcTitle
		
		Local lcTitle, lnDialogBoxType
		
		If Empty(tcErrorMessage) or !This.oSearchOptions.lShowErrorMessages
			Return
		EndIf
		
		lnDialogBoxType	= Evl(tnDialogBoxType, 0)
		lcTitle					= Evl(tcTitle, 'GoFishSearchEngine Error:')  
		
		MessageBox(tcErrorMessage, lnDialogBoxType, lcTitle)  
	ENDPROC

	PROCEDURE showwaitmessage
		Lparameters tcMessage
		
		If This.oSearchOptions.lShowWaitMessages
			Wait Window At 5, Wcols() / 2 Nowait tcMessage
		EndIf
		
	ENDPROC

	PROCEDURE startprogressbar
		Lparameters tnMaxValue
		
		If Vartype(This.oProgressBar) = 'O'
			This.oProgressBar.Start(tnMaxValue)
		Endif
		 
	ENDPROC

	PROCEDURE starttimer
		This.nSearchTime = Seconds()
	ENDPROC

	PROCEDURE stopprogressbar
		If Vartype(This.oProgressBar) = 'O'
			This.oProgressBar.Stop()
		Endif
		
	ENDPROC

	PROCEDURE storeinitialdefaultdir
		This.cInitialDefaultDir = Sys(5) + Sys(2003)
	ENDPROC

	PROCEDURE timestamptodate		&& Handles the conversion of the FoxPro TIMESTAMP field to a readable (and understandable) date and time. By Rick Schummer.
		*  METHOD: TimeStamp2Date()
		*
		*  AUTHOR: Richard A. Schummer            September 1994
		*
		*  COPYRIGHT (c) 1994-2001    Richard A. Schummer
		*     42759 Flis Dr  
		*     Sterling Heights, MI  48314-2850
		*     RSchummer@CompuServe.com
		*
		*  METHOD DESCRIPTION: 
		*     This procedure handles the conversion of the FoxPro TIMESTAMP field to 
		*     a readable (and understandable) date and time.  The procedure will return
		*     the date/time in three formats based on the cStyle parameter.  Timestamp 
		*     field is a 32-bit (numeric compressed) system that the FoxPro development
		*     team created to save on file space in the projects, screens, reports, and
		*     label databases.  This field is used to determine if objects need to be 
		*     recompiled (project manager), or syncronized across platforms (screens,
		*     reports, and labels).
		* 
		*  CALLING SYNTAX: 
		*     <variable> = ctrMetaDecode.TimeStamp2Date(<nTimeStamp>,<cStyle>)
		*
		*     Sample:
		*     ltDateTime = ctrMetaDecode.TimeStamp2Date(TimeStamp,"DATETIME")
		* 
		*  INPUT PARAMETERS: 
		*     nTimeStamp = Required field, must be numeric, no check to verify the
		*                  data passed is valid FoxPro Timestamp, just be sure it is
		*     cStyle     = Not required (defaults to "DATETIME"), must be character, 
		*                  and must be one of the following:
		*                   "DATETIME" will return the date/time in MM/DD/YY HH:MM:SS
		*                   "DATE"     will return the date in MM/DD/YY format
		*                   "TIME"     will return the time in HH:MM:SS format
		*
		*  OUTPUT PARAMETERS:
		*     lcRetval    = The date/time (in requested format) is returned in 
		*                   character type.  Must be converted and parsed to be
		*                   used as date type.
		*
		
		
		*=============================================================
		* Tried to use this FFC class, but it sometimes gave an error:
		* This.oFrxCursor.GetTimeStampString(timestamp)
		*=============================================================
		
		
		Lparameter tnTimeStamp, tcStyle
		
		Local lcRetVal                         &&  Requested data returned from procedure, ;
			lnYear, ;
			lnMonth, ;
			lnDay, ;
			lnHour, ;
			lnMinute, ;
			lnSecond
		
		If Type('tnTimeStamp') != "N"          &&  Timestamp must be numeric
			*Wait Window "Time stamp passed is not numeric" NoWait
			Return ""
		Endif
		
		If tnTimeStamp = 0                     &&  Timestamp is zero until built in project
			Return "Not built into App"
		Endif
		
		If Type('tcStyle') != "C"              &&  Default return style to both date and time
			tcStyle = "DATETIME"
		Endif
		
		If !Inlist(Upper(tcStyle), "DATE", "TIME", "DATETIME")
			Wait Window "Style parameter must be DATE, TIME, or DATETIME"
			Return ""
		Endif
		
		lnYear   = ((tnTimeStamp / (2 ** 25) + 1980))
		lnMonth  = ((lnYear - Int(lnYear)    ) * (2 ** 25)) / (2 ** 21)
		lnDay    = ((lnMonth - Int(lnMonth)  ) * (2 ** 21)) / (2 ** 16)
		
		lnHour   = ((lnDay - Int(lnDay)      ) * (2 ** 16)) / (2 ** 11)
		lnMinute = ((lnHour - Int(lnHour)    ) * (2 ** 11)) / (2 ** 05)
		lnSecond = ((lnMinute - Int(lnMinute)) * (2 ** 05)) * 2       &&  Multiply by two to correct
		&&  truncation problem built in
		&&  to the creation algorithm
		&&  (Source: Microsoft Tech Support)
		
		lcRetVal = ""
		
		If "DATE" $ Upper(tcStyle)
		*< 4-Feb-2001 Fixed to display date in machine designated format (Regional Settings)
		*< lcRetVal = lcRetVal + RIGHT("0"+ALLTRIM(STR(INT(lnMonth))),2) + "/" + ;
		*<                       RIGHT("0"+ALLTRIM(STR(INT(lnDay))),2)   + "/" + ;
		*<                       RIGHT("0"+ALLTRIM(STR(INT(lnYear))), IIF(SET("CENTURY") = "ON", 4, 2))
		
		*< RAS 23-Nov-2004, change to work around behavior change in VFP 9.
		*< lcRetVal = lcRetVal + DTOC(DATE(lnYear, lnMonth, lnDay))
			lcRetVal = lcRetVal + Dtoc(Date(Int(lnYear), Int(lnMonth), Int(lnDay)))
		Endif
		
		If "TIME" $ Upper(tcStyle)
			lcRetVal = lcRetVal + Iif("DATE" $ Upper(tcStyle), " ", "")
			lcRetVal = lcRetVal + Right("0" + Alltrim(Str(Int(lnHour))), 2)   + ":" + ;
				Right("0" + Alltrim(Str(Int(lnMinute))), 2) + ":" + ;
				Right("0" + Alltrim(Str(Int(lnSecond))), 2)
		Endif
		
		Return lcRetVal
		
		
	ENDPROC

	PROCEDURE trimwhitespace
		Lparameters tcString
		
		Local lcTrimmedString
		
		lcTrimmedString = Alltrim(tcString, 1, Chr(32), Chr(9), Chr(10), Chr(13), Chr(0))
		lcTrimmedString = Strtran(lcTrimmedString , Chr(9), Chr(32))
		
		Return lcTrimmedString 
	ENDPROC

	PROCEDURE updatecursorafterreplace		&& Updates the match position fields on remaining rows in the results cursor after a replace opertion is performed on a row.
		Lparameters tcCursor, toResult
		
		Local lcColumn, lcFileToModify, lnChangeLength, lnCurrentRecno, lnMatchStart, lnProcStart
		Local lnResultRecno, lnSelect
		
		If This.oSearchOptions.lPreviewReplace = .t.
			Return
		Endif
		
		lnChangeLength = toResult.nChangeLength
		
		lnSelect = Select()
		Select (tcCursor)
		lnCurrentRecno = Recno()
		
		*-- Create local vars of certain fields from the current row that we need to use below
		lcFileToModify = Alltrim(filepath)
		lnResultRecno = recno
		lnProcStart = procstart
		lnMatchStart = matchstart
		lcColumn = Column
		
		*-- Cannot process same source code line more than once, so mark this and all other rows of
		*-- the same oringal source line with replacd = .t., and also update the matchlen
		Update &tcCursor ;
			Set replaced = .t., ;
				matchlen = Max(matchlen + lnChangeLength, 0) ;
				Where Alltrim(filepath) == lcFileToModify And ;
		 			  recno = lnResultRecno And ;
		 			  column = lcColumn And ;
		 			  matchstart = lnMatchStart
		 			  
		*-- Update the stored code with the new code for all records of the same original source
		Update &tcCursor ;
			Set	code = toResult.cNewCode;
				Where Alltrim(filepath) == lcFileToModify And ;
		 			  recno = lnResultRecno And ;
		 			  column = lcColumn
		
			*-- Update matchstart values on remaining records of same file, recno, and column type
			Update &tcCursor ;
				Set matchstart = (matchstart + lnChangeLength) ;
				Where Alltrim(filepath) == lcFileToModify And ;
			 		  recno = lnResultRecno And ;
			 		  column = lcColumn And ;
			 		  matchstart > lnMatchStart
		
			*-- Update procstart values on remaining records of same file, recno, and column type
			Update &tcCursor ;
				Set procstart = (procstart + lnChangeLength) ;
				Where Alltrim(filepath) == lcFileToModify And ;
					  recno = lnResultRecno And ;
					  column = lcColumn And ;
					  procstart > lnProcStart
		
		Goto (lnCurrentRecno)  
		
		Select (lnSelect)   
	ENDPROC

	PROCEDURE updateprogressbar
		Lparameters tnValue
		
		If Vartype(This.oProgressBar) = 'O'
			This.oProgressBar.nValue = tnValue
		Endif
		
	ENDPROC

	PROCEDURE updatereplacehistoryrecord
		*-- If we are in Replace Preview mode, do not attempt to update the Replace Detail record.
		
		If This.oSearchOptions.lPreviewReplace = .f.
			Update (This.cReplaceHistoryTable) Set replaces = This.nReplaceCount Where id = this.nReplaceHistoryId 
		Endif
	ENDPROC

ENDDEFINE

DEFINE CLASS gofishsearchoptions_thor AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "gofish.h"
	*<DefinedPropArrayMethod>
		*m: lregularexpression_access
		*p: cescapedsearchexpression		&& This is the escaped version of the cSearchExpression that is used for the actual Reg Ex search. The class maintains this, so the class user should never touch this.
		*p: cfiletemplate		&& A file mask template, like Job*, or *Job, or *job*, or Job*.scx, or *.scx, etc.
		*p: cindexstring
		*p: cotherincludes		&& An additional list of file extensions to be included in the search. Just separate each extension by a space. No dot is needed. Case does not matter.
		*p: cpath		&& This property can be used to store the name of a Path on the object.
		*p: cproject		&& This property can be used to store the name of a Project on the object.
		*p: crecentscope
		*p: creplaceexpression
		*p: csearchexpression		&& Search expression to be sought. Can be a regex. Set lRegularExpression to .t. if it is.
		*p: dtimestampfrom
		*p: dtimestampto
		*p: lallowblankreplace		&& This flag must be set in order to do a replace operation where the replacement string is a blank string.
		*p: lbackup
		*p: lcolorizevfpcode
		*p: lcreateresultscollection		&& Indicates if you want to store each match result object into the oResults colleciton on the Search Engine class.
		*p: lcreateresultscursor		&& Inidcates if you want to store each search result in a local cursor. See cSearchResultsAlias propertyy on the Search Class for the namee of the Cursor.
		*p: ldonotshowreplacewarning		&& This will supress the warning dialog that pops up every time you perform a replace.
		*p: lenablereplacemode
		*p: lincludeallfiletypes		&& Not used.
		*p: lincludeasp
		*p: lincludedbc
		*p: lincludefrx
		*p: lincludeh
		*p: lincludehtml
		*p: lincludeini
		*p: lincludejava
		*p: lincludejsp
		*p: lincludelbx
		*p: lincludemnx
		*p: lincludempr
		*p: lincludepjx
		*p: lincludeprg
		*p: lincludescx
		*p: lincludespr
		*p: lincludesubdirectories
		*p: lincludetxt
		*p: lincludevcx
		*p: lincludexml
		*p: llimittoprojectfolder		&& When searching a PJX file, this flag will skip over searches on any files in the project which are not located in or below the Project's home path.
		*p: lmatchcase
		*p: lmatchwholeword
		*p: lpreviewreplace
		*p: lregularexpression		&& Indicates if the cSearchExpression is intended to be used as a Regular Expression.
		*p: lsearchincomments
		*p: lshowadvancedformonstartup
		*p: lshowerrormessages		&& Determines if a messagebox will pop up any time there is an error on the Search or Replace family of methods.
		*p: lshownomatchesmessage		&& Display a MessageBox at the end of a search if there were no matches found.
		*p: lshowwaitmessages		&& Will display the name of each file in a wait window as they are being processed. Caution: using this feature slows down the search a good bit.
		*p: lskipfiles		&& A flag to indicate if the user wants to process the files in cFilesToSkipFile files to skip over certain files during the search.
		*p: lstorecode		&& Indicates if you want a copy of the code block stored on each search reesult record (for ResultsCursor) or collection node (for ResultsCollection).
		*p: ltimestamp		&& Indicates if the search will be limited to filedates and object TimeStamps that fall on or between the dTimeStampForm and dTimeStampTo values.
		*p: lwarnwhenunabletoopenfilesduringsearch
		*p: nhtmlmatchlinecolor
		*p: nmaxresults		&& Limits the amx number of results created. Search will stop at this limit. Collection restutls over 50,000 with lStoreCode = .t. could lead to memory problems.
		*p: nsearchmode		&& Indicates which search mode to use: Plain, LIKE, or RegEx. See GoFish.h constants file for values.
		*p: nsearchscope		&& 1 = Active Project, 2=Browse Project, 3 = Current Dir, 4= Browse Directory
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cescapedsearchexpression = 		&& This is the escaped version of the cSearchExpression that is used for the actual Reg Ex search. The class maintains this, so the class user should never touch this.
	cfiletemplate = 		&& A file mask template, like Job*, or *Job, or *job*, or Job*.scx, or *.scx, etc.
	cindexstring = 
	cotherincludes = 		&& An additional list of file extensions to be included in the search. Just separate each extension by a space. No dot is needed. Case does not matter.
	cpath = 		&& This property can be used to store the name of a Path on the object.
	cproject = 		&& This property can be used to store the name of a Project on the object.
	crecentscope = 
	creplaceexpression = 
	csearchexpression = 		&& Search expression to be sought. Can be a regex. Set lRegularExpression to .t. if it is.
	dtimestampfrom = {}
	dtimestampto = {}
	Height = 18
	lallowblankreplace = .F.		&& This flag must be set in order to do a replace operation where the replacement string is a blank string.
	lbackup = .T.
	lcolorizevfpcode = .F.
	lcreateresultscollection = .F.		&& Indicates if you want to store each match result object into the oResults colleciton on the Search Engine class.
	lcreateresultscursor = .T.		&& Inidcates if you want to store each search result in a local cursor. See cSearchResultsAlias propertyy on the Search Class for the namee of the Cursor.
	ldonotshowreplacewarning = .F.		&& This will supress the warning dialog that pops up every time you perform a replace.
	lenablereplacemode = .F.
	lincludeallfiletypes = .F.		&& Not used.
	lincludeasp = .T.
	lincludedbc = .F.
	lincludefrx = .T.
	lincludeh = .T.
	lincludehtml = .T.
	lincludeini = .T.
	lincludejava = .T.
	lincludejsp = .T.
	lincludelbx = .T.
	lincludemnx = .T.
	lincludempr = .T.
	lincludepjx = .F.
	lincludeprg = .T.
	lincludescx = .T.
	lincludespr = .T.
	lincludesubdirectories = .T.
	lincludetxt = .T.
	lincludevcx = .T.
	lincludexml = .T.
	llimittoprojectfolder = .F.		&& When searching a PJX file, this flag will skip over searches on any files in the project which are not located in or below the Project's home path.
	lmatchcase = .F.
	lmatchwholeword = .F.
	lpreviewreplace = .T.
	lregularexpression = .F.		&& Indicates if the cSearchExpression is intended to be used as a Regular Expression.
	lsearchincomments = .T.
	lshowadvancedformonstartup = .F.
	lshowerrormessages = .T.		&& Determines if a messagebox will pop up any time there is an error on the Search or Replace family of methods.
	lshownomatchesmessage = .T.		&& Display a MessageBox at the end of a search if there were no matches found.
	lshowwaitmessages = .F.		&& Will display the name of each file in a wait window as they are being processed. Caution: using this feature slows down the search a good bit.
	lskipfiles = .F.		&& A flag to indicate if the user wants to process the files in cFilesToSkipFile files to skip over certain files during the search.
	lstorecode = .F.		&& Indicates if you want a copy of the code block stored on each search reesult record (for ResultsCursor) or collection node (for ResultsCollection).
	ltimestamp = .F.		&& Indicates if the search will be limited to filedates and object TimeStamps that fall on or between the dTimeStampForm and dTimeStampTo values.
	lwarnwhenunabletoopenfilesduringsearch = .T.
	Name = "gofishsearchoptions_thor"
	nhtmlmatchlinecolor = 8454143
	nmaxresults = 10000		&& Limits the amx number of results created. Search will stop at this limit. Collection restutls over 50,000 with lStoreCode = .t. could lead to memory problems.
	nsearchmode = 1		&& Indicates which search mode to use: Plain, LIKE, or RegEx. See GoFish.h constants file for values.
	nsearchscope = 1		&& 1 = Active Project, 2=Browse Project, 3 = Current Dir, 4= Browse Directory
	Width = 160
	_memberdata = <VFPData>
		<memberdata name="lincludescx" display="lIncludeSCX"/>
		<memberdata name="lincludevcx" display="lIncludeVCX"/>
		<memberdata name="lincludedbc" display="lIncludeDBC"/>
		<memberdata name="lincludemnx" display="lIncludeMNX"/>
		<memberdata name="lincludelbx" display="lIncludeLBX"/>
		<memberdata name="lincludefrx" display="lIncludeFRX"/>
		<memberdata name="lincludepjx" display="lIncludePJX"/>
		<memberdata name="lincludeprg" display="lIncludePRG"/>
		<memberdata name="lincludespr" display="lIncludeSPR"/>
		<memberdata name="lincludempr" display="lIncludeMPR"/>
		<memberdata name="lincludehtml" display="lIncludeHTML"/>
		<memberdata name="lincludeh" display="lIncludeH"/>
		<memberdata name="lincludeasp" display="lIncludeASP"/>
		<memberdata name="lincludeini" display="lIncludeINI"/>
		<memberdata name="lincludejava" display="lIncludeJAVA"/>
		<memberdata name="lincludejsp" display="lIncludeJSP"/>
		<memberdata name="lincludexml" display="lIncludeXML"/>
		<memberdata name="lincludetxt" display="lIncludeTXT"/>
		<memberdata name="cotherincludes" display="cOtherIncludes"/>
		<memberdata name="lsearchincomments" display="lSearchInComments"/>
		<memberdata name="ltimestamp" display="lTimeStamp"/>
		<memberdata name="dtimestampfrom" display="dTimeStampFrom"/>
		<memberdata name="dtimestampto" display="dTimeStampTo"/>
		<memberdata name="cescapedsearchexpression" display="cEscapedSearchExpression"/>
		<memberdata name="cpath" display="cPath"/>
		<memberdata name="cproject" display="cProject"/>
		<memberdata name="creplaceexpression" display="cReplaceExpression"/>
		<memberdata name="csearchexpression" display="cSearchExpression"/>
		<memberdata name="lallowblankreplace" display="lAllowBlankReplace"/>
		<memberdata name="lcreateresultscollection" display="lCreateResultsCollection"/>
		<memberdata name="lcreateresultscursor" display="lCreateResultsCursor"/>
		<memberdata name="lincludesubdirectories" display="lIncludeSubdirectories"/>
		<memberdata name="lmatchcase" display="lMatchCase"/>
		<memberdata name="lmatchwholeword" display="lMatchWholeWord"/>
		<memberdata name="lregularexpression" display="lRegularExpression"/>
		<memberdata name="lshowerrormessages" display="lShowErrorMessages"/>
		<memberdata name="lstorecode" display="lStoreCode"/>
		<memberdata name="nmaxresults" display="nMaxResults"/>
		<memberdata name="lshowwaitmessages" display="lShowWaitMessages"/>
		<memberdata name="lcolorizevfpcode" display="lColorizeVFPCode"/>
		<memberdata name="llimittoprojectfolder" display="lLimitToProjectFolder"/>
		<memberdata name="cindexstring" display="cIndexString"/>
		<memberdata name="lwarnwhenunabletoopenfilesduringsearch" display="lWarnWhenUnableToOpenFilesDuringSearch"/>
		<memberdata name="nhtmlmatchlinecolor" display="nHtmlMatchLineColor"/>
		<memberdata name="nsearchscope" display="nSearchScope"/>
		<memberdata name="lshownomatchesmessage" display="lShowNoMatchesMessage"/>
		<memberdata name="lincludeallfiletypes" display="lIncludeAllFileTypes"/>
		<memberdata name="cfiletemplate" display="cFileTemplate"/>
		<memberdata name="lpreviewreplace" display="lPreviewReplace"/>
		<memberdata name="lbackup" display="lBackup"/>
		<memberdata name="lenablereplacemode" display="lEnableReplaceMode"/>
		<memberdata name="crecentscope" display="cRecentScope"/>
		<memberdata name="lshowadvancedformonstartup" display="lShowAdvancedFormOnStartup"/>
		<memberdata name="ldonotshowreplacewarning" display="lDoNotShowReplaceWarning"/>
		<memberdata name="lskipfiles" display="lSKipFiles"/>
		<memberdata name="lregularexpression_access" display="lRegularExpression_Access"/>
		<memberdata name="nsearchmode" display="nSearchMode"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE lregularexpression_access
		Return (This.nSearchMode = GF_SEARCH_MODE_REGEX)
		
	ENDPROC

ENDDEFINE
